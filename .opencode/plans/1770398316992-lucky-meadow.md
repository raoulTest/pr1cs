# APCS Maritime Port Booking System - Exhaustive Backend Implementation Plan

## Executive Summary

This plan details the complete backend implementation for APCS (Advanced Port Container System). The system transforms from a gate-level booking model to a **terminal-level capacity model** with **container-centric bookings** and a **French-only AI assistant**.

### Key Architectural Changes

| Current State | Target State |
|--------------|--------------|
| Carrier companies own trucks | Trucks owned directly by carrier users |
| Gate-level capacity | Terminal-level capacity (truck count) |
| Single container per booking | Multiple containers per booking |
| Manual approval only | Auto-validation (first N% auto-approved) |
| Gate assigned at booking | Gate assigned at approval |
| Bilingual (EN/FR) | French only |
| No containers table | Pre-seeded containers assigned to carriers |

### Slot Management Model

**Configuration = Static, Instances = Dynamic**

- Terminals define a **slot template**: operating hours (e.g., 00:00-23:00) + slot duration (1 hour) = 24 possible slots/day
- **No pre-creation of slot records** - slots are virtual until first booking
- **Availability queries** return all possible slots based on template, showing `0/capacity` for empty slots
- **Slot records created on first booking** to track `currentBookings` count
- This avoids creating 168+ slot records per terminal per week while still showing full availability

---

## Phase 1: Schema Refactoring

**Files to Modify:**
- `packages/backend/convex/schema.ts` (major refactor)
- `packages/backend/convex/lib/validators.ts` (add new validators)

### 1.1 Tables to Remove

```typescript
// DELETE these tables entirely
carrierCompanies: defineTable({ ... })  // REMOVE
carrierUsers: defineTable({ ... })      // REMOVE
```

### 1.2 New `containers` Table

```typescript
/** Container type (ISO standard classifications) */
export const containerTypeValidator = v.union(
  v.literal("dry"),           // Standard dry container
  v.literal("reefer"),        // Refrigerated
  v.literal("open_top"),      // Open top
  v.literal("flat_rack"),     // Flat rack
  v.literal("tank"),          // Tank container
  v.literal("hazardous")      // Hazardous materials
);

/** Container dimensions (ISO standard) */
export const containerDimensionsValidator = v.union(
  v.literal("20ft"),          // 20' standard
  v.literal("40ft"),          // 40' standard
  v.literal("40ft_hc"),       // 40' high cube
  v.literal("45ft")           // 45' high cube
);

/** Container weight class */
export const containerWeightClassValidator = v.union(
  v.literal("light"),         // < 10 tons
  v.literal("medium"),        // 10-20 tons
  v.literal("heavy"),         // 20-30 tons
  v.literal("super_heavy")    // > 30 tons
);

/** Container operation type */
export const containerOperationValidator = v.union(
  v.literal("pick_up"),       // Carrier picks up from terminal
  v.literal("drop_off")       // Carrier drops off at terminal
);

containers: defineTable({
  // Ownership
  ownerId: v.string(),                          // Better Auth user ID (carrier role)
  
  // ISO 6346 container identification
  containerNumber: v.string(),                   // e.g., "MSCU1234567"
  
  // Classification
  containerType: containerTypeValidator,
  dimensions: containerDimensionsValidator,
  weightClass: containerWeightClassValidator,
  
  // Operation details
  operationType: containerOperationValidator,
  
  // For pick_up: when container will be ready for collection
  readyDate: v.optional(v.number()),
  // For drop_off: expected departure date from terminal
  departureDate: v.optional(v.number()),
  
  // State
  isEmpty: v.boolean(),                          // Empty vs loaded
  isActive: v.boolean(),                         // Soft delete flag
  
  // Booking association (null if not booked)
  bookingId: v.optional(v.id("bookings")),
  
  // Metadata
  notes: v.optional(v.string()),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_owner", ["ownerId"])
  .index("by_owner_and_active", ["ownerId", "isActive"])
  .index("by_container_number", ["containerNumber"])
  .index("by_operation", ["operationType"])
  .index("by_booking", ["bookingId"])
  .index("by_type", ["containerType"])
  .index("by_owner_and_operation", ["ownerId", "operationType"])
  .index("by_owner_available", ["ownerId", "isActive", "bookingId"]),
```

### 1.3 Refactored `trucks` Table

```typescript
trucks: defineTable({
  // CHANGED: Direct ownership by carrier user (no company)
  ownerId: v.string(),                           // Better Auth user ID (carrier role)
  
  licensePlate: v.string(),
  truckType: truckTypeValidator,
  truckClass: truckClassValidator,
  
  // Vehicle details
  make: v.optional(v.string()),
  model: v.optional(v.string()),
  year: v.optional(v.number()),
  maxWeight: v.optional(v.number()),             // Capacity in tons
  
  isActive: v.boolean(),
  createdAt: v.number(),
  updatedAt: v.number(),
  createdBy: v.string(),
})
  // CHANGED indexes
  .index("by_owner", ["ownerId"])
  .index("by_owner_and_active", ["ownerId", "isActive"])
  .index("by_license_plate", ["licensePlate"])
  .index("by_type", ["truckType"])
  .index("by_class", ["truckClass"]),
```

### 1.4 Refactored `bookings` Table

```typescript
bookings: defineTable({
  // CHANGED: Terminal-level (gate assigned later)
  terminalId: v.id("terminals"),
  carrierId: v.string(),                         // Better Auth user ID (was carrierCompanyId)
  truckId: v.id("trucks"),
  
  // CHANGED: Gate assigned at approval, not booking
  gateId: v.optional(v.id("gates")),             // Now optional, assigned on confirm
  
  // CHANGED: Multiple containers per booking
  containerIds: v.array(v.id("containers")),
  
  // Reference (terminal-prefixed)
  bookingReference: v.string(),                   // e.g., "TER1-BK-001234"
  status: bookingStatusValidator,
  
  // ADDED: Auto-validation tracking
  wasAutoValidated: v.boolean(),
  
  // Preferred slot (before gate assignment)
  preferredDate: v.string(),                      // YYYY-MM-DD
  preferredTimeStart: v.string(),                 // HH:mm
  preferredTimeEnd: v.string(),                   // HH:mm
  
  // ADDED: QR scan timestamps
  entryScannedAt: v.optional(v.number()),
  exitScannedAt: v.optional(v.number()),
  scannedByEntry: v.optional(v.string()),        // Operator who scanned entry
  scannedByExit: v.optional(v.string()),         // Operator who scanned exit
  
  // QR code
  qrCode: v.optional(v.string()),                 // Data URL
  qrCodeStorageId: v.optional(v.id("_storage")), // Convex file storage
  
  // Driver info
  driverName: v.optional(v.string()),
  driverPhone: v.optional(v.string()),
  driverIdNumber: v.optional(v.string()),
  
  // Timestamps
  bookedAt: v.number(),
  confirmedAt: v.optional(v.number()),
  rejectedAt: v.optional(v.number()),
  cancelledAt: v.optional(v.number()),
  expiredAt: v.optional(v.number()),
  
  // Status metadata
  statusReason: v.optional(v.string()),
  processedBy: v.optional(v.string()),
  
  createdBy: v.string(),
  updatedAt: v.number(),
})
  .index("by_reference", ["bookingReference"])
  .index("by_carrier", ["carrierId"])
  .index("by_carrier_and_status", ["carrierId", "status"])
  .index("by_terminal", ["terminalId"])
  .index("by_terminal_and_status", ["terminalId", "status"])
  .index("by_terminal_and_date", ["terminalId", "preferredDate"])
  .index("by_gate", ["gateId"])
  .index("by_truck", ["truckId"])
  .index("by_status", ["status"])
  .index("by_date", ["preferredDate"])
  .index("by_created_by", ["createdBy"]),
```

### 1.5 Refactored `timeSlots` Table

**Note: Slot records are ONLY created when a booking is made for that slot.**
Virtual slots (no bookings yet) are computed from terminal operating hours.

```typescript
timeSlots: defineTable({
  // CHANGED: Terminal-level, not gate-level
  terminalId: v.id("terminals"),
  
  date: v.string(),                               // YYYY-MM-DD
  startTime: v.string(),                          // HH:mm (24h)
  endTime: v.string(),                            // HH:mm (24h)
  
  // Terminal capacity (truck count) - inherited from terminal.defaultSlotCapacity
  maxCapacity: v.number(),
  currentBookings: v.number(),                    // Confirmed + pending count
  
  // ADDED: Auto-validation threshold for this slot (override terminal default)
  autoValidationThreshold: v.optional(v.number()), // 0-100%, null = use terminal default
  
  // Slot can be disabled by operator
  isActive: v.boolean(),
  createdAt: v.number(),
  updatedAt: v.number(),
  createdBy: v.string(),
})
  .index("by_terminal", ["terminalId"])
  .index("by_terminal_and_date", ["terminalId", "date"])
  .index("by_date", ["date"])
  .index("by_terminal_and_active", ["terminalId", "isActive"]),
```

### 1.6 Updated `terminals` Table

```typescript
terminals: defineTable({
  name: v.string(),
  code: v.string(),                               // e.g., "TER1"
  address: v.optional(v.string()),
  timezone: v.string(),
  isActive: v.boolean(),
  
  // ADDED: Terminal-wide capacity settings
  defaultSlotCapacity: v.number(),                // Default trucks per slot
  autoValidationThreshold: v.number(),            // Default 0-100 (percentage)
  
  // ADDED: Capacity alert thresholds
  capacityAlertThresholds: v.array(v.number()),   // e.g., [70, 85, 95]
  
  // ADDED: Operating hours
  operatingHoursStart: v.string(),                // e.g., "06:00"
  operatingHoursEnd: v.string(),                  // e.g., "22:00"
  slotDurationMinutes: v.number(),                // e.g., 60
  
  createdAt: v.number(),
  updatedAt: v.number(),
  createdBy: v.string(),
})
  .index("by_code", ["code"])
  .index("by_active", ["isActive"])
  .index("by_created_by", ["createdBy"]),
```

### 1.7 New `auditLogs` Table

```typescript
/** Audit action types */
export const auditActionValidator = v.union(
  v.literal("query"),
  v.literal("mutation"),
  v.literal("ai_tool_call"),
  v.literal("login"),
  v.literal("logout"),
  v.literal("failed_auth"),
  v.literal("permission_denied")
);

auditLogs: defineTable({
  // Who
  userId: v.optional(v.string()),                 // null for anonymous/failed auth
  
  // What
  action: auditActionValidator,
  resource: v.string(),                           // e.g., "bookings.create"
  resourceId: v.optional(v.string()),             // Document ID if applicable
  
  // Details
  args: v.optional(v.string()),                   // JSON string (sanitized, no secrets)
  result: v.optional(v.string()),                 // "success", "error:CODE", etc.
  errorMessage: v.optional(v.string()),
  
  // Context
  ipAddress: v.optional(v.string()),
  userAgent: v.optional(v.string()),
  sessionId: v.optional(v.string()),
  
  // AI-specific
  aiThreadId: v.optional(v.string()),
  aiToolName: v.optional(v.string()),
  
  // Timing
  timestamp: v.number(),
  durationMs: v.optional(v.number()),
})
  .index("by_user", ["userId"])
  .index("by_action", ["action"])
  .index("by_resource", ["resource"])
  .index("by_timestamp", ["timestamp"])
  .index("by_user_and_action", ["userId", "action"])
  .index("by_ai_thread", ["aiThreadId"]),
```

### 1.8 New `bookingAggregates` Table (Analytics)

```typescript
/** Aggregation period */
export const aggregationPeriodValidator = v.union(
  v.literal("hourly"),
  v.literal("daily"),
  v.literal("weekly")
);

bookingAggregates: defineTable({
  // Scope
  terminalId: v.id("terminals"),
  period: aggregationPeriodValidator,
  date: v.string(),                               // YYYY-MM-DD
  hour: v.optional(v.number()),                   // 0-23 for hourly aggregates
  
  // Booking counts by status
  totalBookings: v.number(),
  pendingCount: v.number(),
  confirmedCount: v.number(),
  rejectedCount: v.number(),
  consumedCount: v.number(),
  cancelledCount: v.number(),
  expiredCount: v.number(),
  autoValidatedCount: v.number(),
  
  // Capacity metrics
  avgUtilizationPercent: v.number(),
  peakUtilizationPercent: v.number(),
  
  // Container metrics
  totalContainers: v.number(),
  pickupCount: v.number(),
  dropoffCount: v.number(),
  
  // Timing metrics (milliseconds)
  avgWaitTimeMs: v.optional(v.number()),          // Time from booking to confirm
  avgProcessingTimeMs: v.optional(v.number()),    // Time in terminal
  
  computedAt: v.number(),
})
  .index("by_terminal", ["terminalId"])
  .index("by_terminal_and_period", ["terminalId", "period"])
  .index("by_terminal_and_date", ["terminalId", "date"])
  .index("by_date", ["date"]),
```

### 1.9 Updated `systemConfig` Table

```typescript
systemConfig: defineTable({
  // Booking window
  maxAdvanceBookingDays: v.number(),              // e.g., 30
  minAdvanceBookingHours: v.number(),             // e.g., 2
  
  // REMOVED: cancellationWindowHours (carriers can cancel anytime)
  
  // ADDED: No-show handling
  noShowGracePeriodMinutes: v.number(),           // e.g., 30
  
  // ADDED: Auto-validation defaults
  defaultAutoValidationThreshold: v.number(),     // 0-100, global default
  
  // Reminder settings
  reminderHoursBefore: v.array(v.number()),
  
  // ADDED: Container settings
  maxContainersPerBooking: v.number(),            // e.g., 10
  
  updatedAt: v.number(),
  updatedBy: v.string(),
}),
```

### 1.10 Updated `userProfiles` Table

```typescript
userProfiles: defineTable({
  userId: v.string(),
  
  // CHANGED: French only, but keep field for future
  preferredLanguage: v.literal("fr"),             // Always French
  notificationChannel: notificationChannelValidator,
  
  phone: v.optional(v.string()),
  
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"]),
```

---

## Phase 2: Core Backend Functions

### 2.1 Container CRUD

**File: `packages/backend/convex/containers/queries.ts`**

```typescript
import { query } from "../_generated/server";
import { v } from "convex/values";
import { getAuthenticatedUser, requireRole, isPortAdmin } from "../lib/permissions";

/**
 * List containers for the current carrier user
 */
export const listMy = query({
  args: {
    operationType: v.optional(containerOperationValidator),
    includeBooked: v.optional(v.boolean()),       // Include containers in bookings
    limit: v.optional(v.number()),
  },
  returns: v.array(v.object({
    _id: v.id("containers"),
    containerNumber: v.string(),
    containerType: containerTypeValidator,
    dimensions: containerDimensionsValidator,
    weightClass: containerWeightClassValidator,
    operationType: containerOperationValidator,
    isEmpty: v.boolean(),
    bookingId: v.optional(v.id("bookings")),
    readyDate: v.optional(v.number()),
    departureDate: v.optional(v.number()),
  })),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);
    requireRole(user, ["carrier"]);

    let query = ctx.db
      .query("containers")
      .withIndex("by_owner_and_active", q => 
        q.eq("ownerId", user.userId).eq("isActive", true)
      );

    const containers = await query.collect();

    return containers
      .filter(c => {
        if (args.operationType && c.operationType !== args.operationType) return false;
        if (!args.includeBooked && c.bookingId) return false;
        return true;
      })
      .slice(0, args.limit ?? 100)
      .map(c => ({
        _id: c._id,
        containerNumber: c.containerNumber,
        containerType: c.containerType,
        dimensions: c.dimensions,
        weightClass: c.weightClass,
        operationType: c.operationType,
        isEmpty: c.isEmpty,
        bookingId: c.bookingId,
        readyDate: c.readyDate,
        departureDate: c.departureDate,
      }));
  },
});

/**
 * Get available containers for booking (not already in a booking)
 */
export const listAvailable = query({
  args: {
    operationType: v.optional(containerOperationValidator),
  },
  returns: v.array(v.object({
    _id: v.id("containers"),
    containerNumber: v.string(),
    containerType: containerTypeValidator,
    dimensions: containerDimensionsValidator,
    operationType: containerOperationValidator,
    isEmpty: v.boolean(),
  })),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);
    requireRole(user, ["carrier"]);

    const containers = await ctx.db
      .query("containers")
      .withIndex("by_owner_available", q =>
        q.eq("ownerId", user.userId).eq("isActive", true).eq("bookingId", undefined)
      )
      .collect();

    return containers
      .filter(c => !args.operationType || c.operationType === args.operationType)
      .map(c => ({
        _id: c._id,
        containerNumber: c.containerNumber,
        containerType: c.containerType,
        dimensions: c.dimensions,
        operationType: c.operationType,
        isEmpty: c.isEmpty,
      }));
  },
});

/**
 * Get container details
 */
export const get = query({
  args: { containerId: v.id("containers") },
  returns: v.union(v.null(), v.object({
    _id: v.id("containers"),
    ownerId: v.string(),
    containerNumber: v.string(),
    containerType: containerTypeValidator,
    dimensions: containerDimensionsValidator,
    weightClass: containerWeightClassValidator,
    operationType: containerOperationValidator,
    isEmpty: v.boolean(),
    isActive: v.boolean(),
    bookingId: v.optional(v.id("bookings")),
    readyDate: v.optional(v.number()),
    departureDate: v.optional(v.number()),
    notes: v.optional(v.string()),
  })),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);
    const container = await ctx.db.get(args.containerId);
    
    if (!container) return null;
    
    // Carriers can only see their own containers
    if (!isPortAdmin(user) && container.ownerId !== user.userId) {
      return null;
    }

    return {
      _id: container._id,
      ownerId: container.ownerId,
      containerNumber: container.containerNumber,
      containerType: container.containerType,
      dimensions: container.dimensions,
      weightClass: container.weightClass,
      operationType: container.operationType,
      isEmpty: container.isEmpty,
      isActive: container.isActive,
      bookingId: container.bookingId,
      readyDate: container.readyDate,
      departureDate: container.departureDate,
      notes: container.notes,
    };
  },
});
```

**File: `packages/backend/convex/containers/mutations.ts`**

```typescript
import { mutation } from "../_generated/server";
import { v, ConvexError } from "convex/values";
import { getAuthenticatedUser, requireRole, isPortAdmin } from "../lib/permissions";

/**
 * Create a container (admin only - containers are pre-seeded)
 */
export const create = mutation({
  args: {
    ownerId: v.string(),
    containerNumber: v.string(),
    containerType: containerTypeValidator,
    dimensions: containerDimensionsValidator,
    weightClass: containerWeightClassValidator,
    operationType: containerOperationValidator,
    isEmpty: v.boolean(),
    readyDate: v.optional(v.number()),
    departureDate: v.optional(v.number()),
    notes: v.optional(v.string()),
  },
  returns: v.id("containers"),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);
    requireRole(user, ["port_admin"]);

    // Validate container number format (ISO 6346)
    if (!isValidContainerNumber(args.containerNumber)) {
      throw new ConvexError({
        code: "INVALID_INPUT",
        message: "Numéro de conteneur invalide (format ISO 6346 requis)",
      });
    }

    // Check for duplicate
    const existing = await ctx.db
      .query("containers")
      .withIndex("by_container_number", q => q.eq("containerNumber", args.containerNumber))
      .first();

    if (existing) {
      throw new ConvexError({
        code: "DUPLICATE",
        message: "Ce numéro de conteneur existe déjà",
      });
    }

    const now = Date.now();
    return await ctx.db.insert("containers", {
      ...args,
      isActive: true,
      createdAt: now,
      updatedAt: now,
    });
  },
});

/**
 * Update container details (carrier can update their own)
 */
export const update = mutation({
  args: {
    containerId: v.id("containers"),
    isEmpty: v.optional(v.boolean()),
    readyDate: v.optional(v.number()),
    departureDate: v.optional(v.number()),
    notes: v.optional(v.string()),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);
    const container = await ctx.db.get(args.containerId);

    if (!container) {
      throw new ConvexError({ code: "NOT_FOUND", message: "Conteneur introuvable" });
    }

    if (!isPortAdmin(user) && container.ownerId !== user.userId) {
      throw new ConvexError({ code: "FORBIDDEN", message: "Accès refusé" });
    }

    // Cannot update if in an active booking
    if (container.bookingId) {
      const booking = await ctx.db.get(container.bookingId);
      if (booking && (booking.status === "pending" || booking.status === "confirmed")) {
        throw new ConvexError({
          code: "INVALID_STATE",
          message: "Impossible de modifier un conteneur dans une réservation active",
        });
      }
    }

    await ctx.db.patch(args.containerId, {
      isEmpty: args.isEmpty ?? container.isEmpty,
      readyDate: args.readyDate,
      departureDate: args.departureDate,
      notes: args.notes,
      updatedAt: Date.now(),
    });

    return null;
  },
});

// Helper: Validate ISO 6346 container number
function isValidContainerNumber(num: string): boolean {
  // Format: 4 letters (owner) + 6 digits + 1 check digit
  // Example: MSCU1234567
  const regex = /^[A-Z]{4}\d{7}$/;
  return regex.test(num);
}
```

### 2.2 Terminal-Level Capacity Engine

**File: `packages/backend/convex/lib/capacity.ts` (REPLACE)**

```typescript
/**
 * Terminal-Level Capacity Management
 * Handles atomic capacity reservation at the terminal level (not gate)
 */
import type { MutationCtx, QueryCtx } from "../_generated/server";
import type { Id, Doc } from "../_generated/dataModel";

export interface CapacityResult {
  available: number;
  total: number;
  booked: number;
  utilizationPercent: number;
}

export interface SlotCapacity extends CapacityResult {
  slotId?: Id<"timeSlots">;                       // undefined for virtual slots
  date: string;
  startTime: string;
  endTime: string;
  autoValidationThreshold: number;
  autoValidatedCount: number;
  remainingAutoValidation: number;
  isVirtual: boolean;                             // true if no slot record exists yet
  isActive: boolean;                              // false if slot was disabled by operator
}

/**
 * Get slot for terminal and time
 */
export async function getSlotForTerminal(
  ctx: QueryCtx,
  terminalId: Id<"terminals">,
  date: string,
  startTime: string
): Promise<Doc<"timeSlots"> | null> {
  return await ctx.db
    .query("timeSlots")
    .withIndex("by_terminal_and_date", q => 
      q.eq("terminalId", terminalId).eq("date", date)
    )
    .filter(q => q.eq(q.field("startTime"), startTime))
    .first();
}

/**
 * Check if a terminal slot has capacity and atomically reserve if available
 */
export async function checkAndReserveCapacity(
  ctx: MutationCtx,
  terminalId: Id<"terminals">,
  date: string,
  startTime: string,
  endTime: string
): Promise<{ success: boolean; slotId?: Id<"timeSlots">; error?: string }> {
  // Find or create the slot
  let slot = await getSlotForTerminal(ctx, terminalId, date, startTime);
  
  if (!slot) {
    // Create slot on-demand with terminal defaults
    const terminal = await ctx.db.get(terminalId);
    if (!terminal) {
      return { success: false, error: "Terminal introuvable" };
    }

    const now = Date.now();
    const slotId = await ctx.db.insert("timeSlots", {
      terminalId,
      date,
      startTime,
      endTime,
      maxCapacity: terminal.defaultSlotCapacity,
      currentBookings: 0,
      isActive: true,
      createdAt: now,
      updatedAt: now,
      createdBy: "system",
    });

    slot = await ctx.db.get(slotId);
  }

  if (!slot || !slot.isActive) {
    return { success: false, error: "Créneau horaire indisponible" };
  }

  // Check capacity
  if (slot.currentBookings >= slot.maxCapacity) {
    return { success: false, error: "Créneau complet" };
  }

  // Atomically increment
  await ctx.db.patch(slot._id, {
    currentBookings: slot.currentBookings + 1,
    updatedAt: Date.now(),
  });

  return { success: true, slotId: slot._id };
}

/**
 * Release capacity (on cancellation/rejection/expiration)
 */
export async function releaseCapacity(
  ctx: MutationCtx,
  slotId: Id<"timeSlots">
): Promise<void> {
  const slot = await ctx.db.get(slotId);
  if (!slot) return;

  await ctx.db.patch(slotId, {
    currentBookings: Math.max(0, slot.currentBookings - 1),
    updatedAt: Date.now(),
  });
}

/**
 * Get terminal capacity for a specific date
 * Returns ALL slots based on terminal operating hours, including virtual slots (no bookings yet)
 */
export async function getTerminalCapacityForDate(
  ctx: QueryCtx,
  terminalId: Id<"terminals">,
  date: string
): Promise<SlotCapacity[]> {
  const terminal = await ctx.db.get(terminalId);
  if (!terminal) return [];

  // Get existing slot records for this date
  const existingSlots = await ctx.db
    .query("timeSlots")
    .withIndex("by_terminal_and_date", q => 
      q.eq("terminalId", terminalId).eq("date", date)
    )
    .collect();

  // Build map of existing slots by startTime
  const slotMap = new Map(existingSlots.map(s => [s.startTime, s]));

  // Generate all possible slots based on terminal operating hours
  const results: SlotCapacity[] = [];
  const startHour = parseInt(terminal.operatingHoursStart.split(":")[0], 10);
  const endHour = parseInt(terminal.operatingHoursEnd.split(":")[0], 10);
  const durationMinutes = terminal.slotDurationMinutes;

  for (let hour = startHour; hour < endHour; hour++) {
    for (let minute = 0; minute < 60; minute += durationMinutes) {
      const startTime = `${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}`;
      const endMinute = minute + durationMinutes;
      const endHourActual = hour + Math.floor(endMinute / 60);
      const endMinuteActual = endMinute % 60;
      const endTime = `${endHourActual.toString().padStart(2, "0")}:${endMinuteActual.toString().padStart(2, "0")}`;

      const existingSlot = slotMap.get(startTime);

      if (existingSlot) {
        // Real slot with bookings
        const bookings = await ctx.db
          .query("bookings")
          .withIndex("by_terminal_and_date", q =>
            q.eq("terminalId", terminalId).eq("preferredDate", date)
          )
          .filter(q => 
            q.and(
              q.eq(q.field("preferredTimeStart"), startTime),
              q.or(
                q.eq(q.field("status"), "pending"),
                q.eq(q.field("status"), "confirmed")
              )
            )
          )
          .collect();

        const autoValidatedCount = bookings.filter(b => b.wasAutoValidated).length;
        const threshold = existingSlot.autoValidationThreshold ?? terminal.autoValidationThreshold;
        const maxAutoValidated = Math.floor((existingSlot.maxCapacity * threshold) / 100);

        results.push({
          slotId: existingSlot._id,
          date,
          startTime,
          endTime,
          available: existingSlot.isActive 
            ? Math.max(0, existingSlot.maxCapacity - existingSlot.currentBookings)
            : 0,
          total: existingSlot.maxCapacity,
          booked: existingSlot.currentBookings,
          utilizationPercent: Math.round((existingSlot.currentBookings / existingSlot.maxCapacity) * 100),
          autoValidationThreshold: threshold,
          autoValidatedCount,
          remainingAutoValidation: Math.max(0, maxAutoValidated - autoValidatedCount),
          isVirtual: false,
          isActive: existingSlot.isActive,
        });
      } else {
        // Virtual slot (no bookings yet) - use terminal defaults
        const threshold = terminal.autoValidationThreshold;
        const maxAutoValidated = Math.floor((terminal.defaultSlotCapacity * threshold) / 100);

        results.push({
          slotId: undefined, // No record exists yet
          date,
          startTime,
          endTime,
          available: terminal.defaultSlotCapacity,
          total: terminal.defaultSlotCapacity,
          booked: 0,
          utilizationPercent: 0,
          autoValidationThreshold: threshold,
          autoValidatedCount: 0,
          remainingAutoValidation: maxAutoValidated,
          isVirtual: true,  // Flag to indicate this is a computed slot
          isActive: true,   // Virtual slots are always active
        });
      }
    }
  }

  return results.sort((a, b) => a.startTime.localeCompare(b.startTime));
}

/**
 * Recalculate capacity for all slots of a terminal on a date
 */
export async function recalculateTerminalCapacity(
  ctx: MutationCtx,
  terminalId: Id<"terminals">,
  date: string
): Promise<void> {
  const slots = await ctx.db
    .query("timeSlots")
    .withIndex("by_terminal_and_date", q => 
      q.eq("terminalId", terminalId).eq("date", date)
    )
    .collect();

  for (const slot of slots) {
    const bookings = await ctx.db
      .query("bookings")
      .withIndex("by_terminal_and_date", q =>
        q.eq("terminalId", terminalId).eq("preferredDate", date)
      )
      .filter(q =>
        q.and(
          q.eq(q.field("preferredTimeStart"), slot.startTime),
          q.or(
            q.eq(q.field("status"), "pending"),
            q.eq(q.field("status"), "confirmed")
          )
        )
      )
      .collect();

    await ctx.db.patch(slot._id, {
      currentBookings: bookings.length,
      updatedAt: Date.now(),
    });
  }
}
```

### 2.3 Auto-Validation Engine

**File: `packages/backend/convex/lib/autoValidation.ts` (CREATE)**

```typescript
/**
 * Auto-Validation Engine
 * Determines if a booking should be auto-approved based on slot utilization
 */
import type { QueryCtx, MutationCtx } from "../_generated/server";
import type { Id } from "../_generated/dataModel";

export interface AutoValidationResult {
  shouldAutoValidate: boolean;
  reason: string;
  threshold: number;
  currentAutoValidated: number;
  maxAutoValidated: number;
}

/**
 * Check if a booking should be auto-validated
 */
export async function shouldAutoValidate(
  ctx: QueryCtx,
  terminalId: Id<"terminals">,
  date: string,
  startTime: string
): Promise<AutoValidationResult> {
  const terminal = await ctx.db.get(terminalId);
  if (!terminal) {
    return {
      shouldAutoValidate: false,
      reason: "Terminal introuvable",
      threshold: 0,
      currentAutoValidated: 0,
      maxAutoValidated: 0,
    };
  }

  // Find the slot
  const slot = await ctx.db
    .query("timeSlots")
    .withIndex("by_terminal_and_date", q =>
      q.eq("terminalId", terminalId).eq("date", date)
    )
    .filter(q => q.eq(q.field("startTime"), startTime))
    .first();

  if (!slot) {
    // No slot yet means first booking - auto-validate
    const threshold = terminal.autoValidationThreshold;
    const maxCapacity = terminal.defaultSlotCapacity;
    const maxAutoValidated = Math.floor((maxCapacity * threshold) / 100);
    
    return {
      shouldAutoValidate: maxAutoValidated > 0,
      reason: maxAutoValidated > 0 
        ? "Premier créneaux - validation automatique" 
        : "Validation automatique désactivée",
      threshold,
      currentAutoValidated: 0,
      maxAutoValidated,
    };
  }

  const threshold = slot.autoValidationThreshold ?? terminal.autoValidationThreshold;
  const maxAutoValidated = Math.floor((slot.maxCapacity * threshold) / 100);

  // Count current auto-validated bookings
  const autoValidatedBookings = await ctx.db
    .query("bookings")
    .withIndex("by_terminal_and_date", q =>
      q.eq("terminalId", terminalId).eq("preferredDate", date)
    )
    .filter(q =>
      q.and(
        q.eq(q.field("preferredTimeStart"), startTime),
        q.eq(q.field("wasAutoValidated"), true),
        q.or(
          q.eq(q.field("status"), "confirmed"),
          q.eq(q.field("status"), "consumed")
        )
      )
    )
    .collect();

  const currentAutoValidated = autoValidatedBookings.length;

  if (currentAutoValidated >= maxAutoValidated) {
    return {
      shouldAutoValidate: false,
      reason: `Seuil atteint (${currentAutoValidated}/${maxAutoValidated})`,
      threshold,
      currentAutoValidated,
      maxAutoValidated,
    };
  }

  return {
    shouldAutoValidate: true,
    reason: `Validation automatique (${currentAutoValidated + 1}/${maxAutoValidated})`,
    threshold,
    currentAutoValidated,
    maxAutoValidated,
  };
}
```

### 2.4 Gate Assignment at Approval

**File: `packages/backend/convex/bookings/internal.ts` (UPDATE)**

Add the following functions:

```typescript
/**
 * Select best gate for a booking at approval time
 * Uses load balancing across compatible gates
 */
export const assignGateForBooking = internalMutation({
  args: {
    bookingId: v.id("bookings"),
  },
  returns: v.union(
    v.object({ success: v.literal(true), gateId: v.id("gates") }),
    v.object({ success: v.literal(false), error: v.string() })
  ),
  handler: async (ctx, args) => {
    const booking = await ctx.db.get(args.bookingId);
    if (!booking) {
      return { success: false, error: "Réservation introuvable" };
    }

    // Get the truck to check compatibility
    const truck = await ctx.db.get(booking.truckId);
    if (!truck) {
      return { success: false, error: "Camion introuvable" };
    }

    // Get all active gates for the terminal
    const gates = await ctx.db
      .query("gates")
      .withIndex("by_terminal_and_active", q =>
        q.eq("terminalId", booking.terminalId).eq("isActive", true)
      )
      .collect();

    if (gates.length === 0) {
      return { success: false, error: "Aucune porte disponible" };
    }

    // Filter compatible gates
    const compatibleGates = gates.filter(gate =>
      gate.allowedTruckTypes.includes(truck.truckType) &&
      gate.allowedTruckClasses.includes(truck.truckClass)
    );

    if (compatibleGates.length === 0) {
      return { 
        success: false, 
        error: `Aucune porte compatible avec ce type de camion (${truck.truckType}/${truck.truckClass})` 
      };
    }

    // Load balance: count confirmed bookings per gate for this time
    const gateCounts: Map<string, number> = new Map();

    for (const gate of compatibleGates) {
      const bookingsAtGate = await ctx.db
        .query("bookings")
        .withIndex("by_gate", q => q.eq("gateId", gate._id))
        .filter(q =>
          q.and(
            q.eq(q.field("preferredDate"), booking.preferredDate),
            q.eq(q.field("preferredTimeStart"), booking.preferredTimeStart),
            q.or(
              q.eq(q.field("status"), "confirmed"),
              q.eq(q.field("status"), "consumed")
            )
          )
        )
        .collect();

      gateCounts.set(gate._id, bookingsAtGate.length);
    }

    // Select gate with least bookings
    let selectedGate = compatibleGates[0];
    let minCount = gateCounts.get(selectedGate._id) ?? 0;

    for (const gate of compatibleGates) {
      const count = gateCounts.get(gate._id) ?? 0;
      if (count < minCount) {
        minCount = count;
        selectedGate = gate;
      }
    }

    return { success: true, gateId: selectedGate._id };
  },
});

/**
 * Generate terminal-prefixed booking reference
 * Format: TER1-BK-XXXXXX (terminal code + 6 digits)
 */
export const generateBookingReference = internalMutation({
  args: {
    terminalId: v.id("terminals"),
  },
  returns: v.string(),
  handler: async (ctx, args) => {
    const terminal = await ctx.db.get(args.terminalId);
    if (!terminal) {
      throw new ConvexError({ code: "NOT_FOUND", message: "Terminal introuvable" });
    }

    // Get last booking for this terminal to determine sequence
    const lastBooking = await ctx.db
      .query("bookings")
      .withIndex("by_terminal", q => q.eq("terminalId", args.terminalId))
      .order("desc")
      .first();

    let sequence = 1;
    if (lastBooking) {
      const match = lastBooking.bookingReference.match(/-(\d{6})$/);
      if (match) {
        sequence = parseInt(match[1], 10) + 1;
      }
    }

    const paddedSequence = sequence.toString().padStart(6, "0");
    return `${terminal.code}-BK-${paddedSequence}`;
  },
});
```

### 2.5 Refactored Booking Mutations

**File: `packages/backend/convex/bookings/mutations.ts` (MAJOR REFACTOR)**

```typescript
/**
 * Create a new booking with multiple containers
 * Terminal-level capacity, auto-validation, gate assigned later
 */
export const create = mutation({
  args: {
    terminalId: v.id("terminals"),
    truckId: v.id("trucks"),
    containerIds: v.array(v.id("containers")),
    preferredDate: v.string(),                    // YYYY-MM-DD
    preferredTimeStart: v.string(),               // HH:mm
    preferredTimeEnd: v.string(),                 // HH:mm
    driverName: v.optional(v.string()),
    driverPhone: v.optional(v.string()),
    driverIdNumber: v.optional(v.string()),
  },
  returns: v.object({
    bookingId: v.id("bookings"),
    bookingReference: v.string(),
    status: bookingStatusValidator,
    wasAutoValidated: v.boolean(),
    gateId: v.optional(v.id("gates")),
  }),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);
    requireRole(user, ["carrier"]);

    // 1. Validate terminal
    const terminal = await ctx.db.get(args.terminalId);
    if (!terminal || !terminal.isActive) {
      throw new ConvexError({
        code: "NOT_FOUND",
        message: "Terminal introuvable ou inactif",
      });
    }

    // 2. Validate truck ownership
    const truck = await ctx.db.get(args.truckId);
    if (!truck || !truck.isActive) {
      throw new ConvexError({ code: "NOT_FOUND", message: "Camion introuvable" });
    }
    if (truck.ownerId !== user.userId) {
      throw new ConvexError({ 
        code: "FORBIDDEN", 
        message: "Ce camion ne vous appartient pas" 
      });
    }

    // 3. Validate containers
    const config = await getSystemConfig(ctx);
    if (args.containerIds.length === 0) {
      throw new ConvexError({
        code: "INVALID_INPUT",
        message: "Au moins un conteneur est requis",
      });
    }
    if (args.containerIds.length > config.maxContainersPerBooking) {
      throw new ConvexError({
        code: "INVALID_INPUT",
        message: `Maximum ${config.maxContainersPerBooking} conteneurs par réservation`,
      });
    }

    // Validate each container
    for (const containerId of args.containerIds) {
      const container = await ctx.db.get(containerId);
      if (!container || !container.isActive) {
        throw new ConvexError({
          code: "NOT_FOUND",
          message: `Conteneur ${containerId} introuvable`,
        });
      }
      if (container.ownerId !== user.userId) {
        throw new ConvexError({
          code: "FORBIDDEN",
          message: `Le conteneur ${container.containerNumber} ne vous appartient pas`,
        });
      }
      if (container.bookingId) {
        throw new ConvexError({
          code: "INVALID_STATE",
          message: `Le conteneur ${container.containerNumber} est déjà dans une réservation`,
        });
      }
    }

    // 4. Validate booking window
    const slotDateTime = new Date(`${args.preferredDate}T${args.preferredTimeStart}`);
    const now = new Date();
    const hoursUntilSlot = (slotDateTime.getTime() - now.getTime()) / (1000 * 60 * 60);

    if (slotDateTime <= now) {
      throw new ConvexError({
        code: "INVALID_INPUT",
        message: "Impossible de réserver un créneau dans le passé",
      });
    }
    if (hoursUntilSlot < config.minAdvanceBookingHours) {
      throw new ConvexError({
        code: "INVALID_INPUT",
        message: `Réservation minimum ${config.minAdvanceBookingHours}h à l'avance`,
      });
    }
    if (hoursUntilSlot / 24 > config.maxAdvanceBookingDays) {
      throw new ConvexError({
        code: "INVALID_INPUT",
        message: `Réservation maximum ${config.maxAdvanceBookingDays} jours à l'avance`,
      });
    }

    // 5. Check if truck already booked for this slot
    const existingBooking = await ctx.db
      .query("bookings")
      .withIndex("by_truck", q => q.eq("truckId", args.truckId))
      .filter(q =>
        q.and(
          q.eq(q.field("preferredDate"), args.preferredDate),
          q.eq(q.field("preferredTimeStart"), args.preferredTimeStart),
          q.or(
            q.eq(q.field("status"), "pending"),
            q.eq(q.field("status"), "confirmed")
          )
        )
      )
      .first();

    if (existingBooking) {
      throw new ConvexError({
        code: "DUPLICATE",
        message: "Ce camion a déjà une réservation pour ce créneau",
      });
    }

    // 6. Reserve capacity at terminal level
    const capacityResult = await checkAndReserveCapacity(
      ctx,
      args.terminalId,
      args.preferredDate,
      args.preferredTimeStart,
      args.preferredTimeEnd
    );

    if (!capacityResult.success) {
      throw new ConvexError({
        code: "CAPACITY_FULL",
        message: capacityResult.error ?? "Créneau complet",
      });
    }

    // 7. Check auto-validation
    const autoValidation = await shouldAutoValidate(
      ctx,
      args.terminalId,
      args.preferredDate,
      args.preferredTimeStart
    );

    // 8. Generate booking reference
    const bookingReference = await ctx.runMutation(
      internal.bookings.internal.generateBookingReference,
      { terminalId: args.terminalId }
    );

    // 9. Determine initial status and gate
    let status: "pending" | "confirmed" = "pending";
    let gateId: Id<"gates"> | undefined = undefined;
    let confirmedAt: number | undefined = undefined;

    if (autoValidation.shouldAutoValidate) {
      // Auto-validate: assign gate immediately
      const gateResult = await ctx.runMutation(
        internal.bookings.internal.assignGateForBooking,
        { bookingId: args.bookingId } // Note: We'll create booking first, then update
      );

      // For auto-validation, we need a two-step process
      // First create pending, then update to confirmed with gate
      status = "confirmed";
      confirmedAt = Date.now();
    }

    // 10. Create booking
    const nowTs = Date.now();
    const bookingId = await ctx.db.insert("bookings", {
      terminalId: args.terminalId,
      carrierId: user.userId,
      truckId: args.truckId,
      containerIds: args.containerIds,
      bookingReference,
      status: "pending", // Start as pending, update if auto-validated
      wasAutoValidated: autoValidation.shouldAutoValidate,
      preferredDate: args.preferredDate,
      preferredTimeStart: args.preferredTimeStart,
      preferredTimeEnd: args.preferredTimeEnd,
      driverName: args.driverName?.trim(),
      driverPhone: args.driverPhone?.trim(),
      driverIdNumber: args.driverIdNumber?.trim(),
      bookedAt: nowTs,
      createdBy: user.userId,
      updatedAt: nowTs,
    });

    // 11. Link containers to booking
    for (const containerId of args.containerIds) {
      await ctx.db.patch(containerId, {
        bookingId,
        updatedAt: nowTs,
      });
    }

    // 12. If auto-validated, confirm and assign gate
    if (autoValidation.shouldAutoValidate) {
      const gateResult = await ctx.runMutation(
        internal.bookings.internal.assignGateForBooking,
        { bookingId }
      );

      if (gateResult.success) {
        await ctx.db.patch(bookingId, {
          status: "confirmed",
          gateId: gateResult.gateId,
          confirmedAt: nowTs,
          processedBy: "system",
          updatedAt: nowTs,
        });

        // Generate QR code
        await ctx.scheduler.runAfter(0, internal.qr.generateQRCode, { bookingId });
      }
    }

    // 13. Record history
    await ctx.runMutation(internal.bookings.internal.recordHistory, {
      bookingId,
      changeType: "created",
      newValue: JSON.stringify({
        terminalId: args.terminalId,
        truckId: args.truckId,
        containerIds: args.containerIds,
        status: autoValidation.shouldAutoValidate ? "confirmed" : "pending",
        wasAutoValidated: autoValidation.shouldAutoValidate,
      }),
      changedBy: user.userId,
      requiredRebook: false,
    });

    // 14. Send notification
    await ctx.scheduler.runAfter(0, internal.notifications.internal.sendBookingNotification, {
      bookingId,
      type: autoValidation.shouldAutoValidate ? "booking_confirmed" : "booking_created",
    });

    const finalBooking = await ctx.db.get(bookingId);

    return {
      bookingId,
      bookingReference,
      status: finalBooking?.status ?? "pending",
      wasAutoValidated: autoValidation.shouldAutoValidate,
      gateId: finalBooking?.gateId,
    };
  },
});

/**
 * Confirm a pending booking (operator/admin)
 * Assigns gate at this point
 */
export const confirm = mutation({
  args: {
    bookingId: v.id("bookings"),
    gateId: v.optional(v.id("gates")),            // Optional: operator can specify
    note: v.optional(v.string()),
  },
  returns: v.object({
    success: v.boolean(),
    gateId: v.optional(v.id("gates")),
    error: v.optional(v.string()),
  }),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);
    requireRole(user, ["port_admin", "terminal_operator"]);

    const booking = await ctx.db.get(args.bookingId);
    if (!booking) {
      return { success: false, error: "Réservation introuvable" };
    }

    // Permission check
    const canModify = await canModifyBookingStatus(ctx, user, args.bookingId, "confirmed");
    if (!canModify) {
      return { success: false, error: "Accès refusé" };
    }

    if (booking.status !== "pending") {
      return { 
        success: false, 
        error: `Impossible de confirmer une réservation avec le statut "${booking.status}"` 
      };
    }

    // Assign gate (use provided or auto-assign)
    let gateId = args.gateId;
    if (!gateId) {
      const gateResult = await ctx.runMutation(
        internal.bookings.internal.assignGateForBooking,
        { bookingId: args.bookingId }
      );

      if (!gateResult.success) {
        return { success: false, error: gateResult.error };
      }
      gateId = gateResult.gateId;
    } else {
      // Validate provided gate
      const gate = await ctx.db.get(gateId);
      if (!gate || !gate.isActive || gate.terminalId !== booking.terminalId) {
        return { success: false, error: "Porte invalide" };
      }
    }

    const now = Date.now();
    await ctx.db.patch(args.bookingId, {
      status: "confirmed",
      gateId,
      confirmedAt: now,
      processedBy: user.userId,
      updatedAt: now,
    });

    // Generate QR code
    await ctx.scheduler.runAfter(0, internal.qr.generateQRCode, { 
      bookingId: args.bookingId 
    });

    // Record history
    await ctx.runMutation(internal.bookings.internal.recordHistory, {
      bookingId: args.bookingId,
      changeType: "status_changed",
      previousValue: "pending",
      newValue: "confirmed",
      changedBy: user.userId,
      note: args.note,
      requiredRebook: false,
    });

    // Send notification
    await ctx.scheduler.runAfter(0, internal.notifications.internal.sendBookingNotification, {
      bookingId: args.bookingId,
      type: "booking_confirmed",
    });

    return { success: true, gateId };
  },
});

/**
 * Cancel a booking (carrier can cancel anytime, operators can cancel any)
 */
export const cancel = mutation({
  args: {
    bookingId: v.id("bookings"),
    reason: v.optional(v.string()),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);

    const booking = await ctx.db.get(args.bookingId);
    if (!booking) {
      throw new ConvexError({ code: "NOT_FOUND", message: "Réservation introuvable" });
    }

    // Permission check
    const canModify = await canModifyBookingStatus(ctx, user, args.bookingId, "cancelled");
    if (!canModify) {
      throw new ConvexError({ code: "FORBIDDEN", message: "Accès refusé" });
    }

    // Carriers can cancel anytime (no cancellation window restriction)
    if (!isValidStatusTransition(booking.status, "cancelled")) {
      throw new ConvexError({
        code: "INVALID_STATE",
        message: `Impossible d'annuler une réservation avec le statut "${booking.status}"`,
      });
    }

    // Release capacity
    const slot = await ctx.db
      .query("timeSlots")
      .withIndex("by_terminal_and_date", q =>
        q.eq("terminalId", booking.terminalId).eq("date", booking.preferredDate)
      )
      .filter(q => q.eq(q.field("startTime"), booking.preferredTimeStart))
      .first();

    if (slot) {
      await releaseCapacity(ctx, slot._id);
    }

    // Unlink containers
    for (const containerId of booking.containerIds) {
      await ctx.db.patch(containerId, {
        bookingId: undefined,
        updatedAt: Date.now(),
      });
    }

    const now = Date.now();
    await ctx.db.patch(args.bookingId, {
      status: "cancelled",
      cancelledAt: now,
      statusReason: args.reason?.trim(),
      processedBy: user.userId,
      updatedAt: now,
    });

    // Record history
    await ctx.runMutation(internal.bookings.internal.recordHistory, {
      bookingId: args.bookingId,
      changeType: "status_changed",
      previousValue: booking.status,
      newValue: "cancelled",
      changedBy: user.userId,
      note: args.reason,
      requiredRebook: false,
    });

    // Send notification
    await ctx.scheduler.runAfter(0, internal.notifications.internal.sendBookingNotification, {
      bookingId: args.bookingId,
      type: "booking_cancelled",
      additionalParams: { reason: args.reason },
    });

    return null;
  },
});

/**
 * Change truck (only allowed modification, status preserved)
 */
export const changeTruck = mutation({
  args: {
    bookingId: v.id("bookings"),
    newTruckId: v.id("trucks"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);

    const booking = await ctx.db.get(args.bookingId);
    if (!booking) {
      throw new ConvexError({ code: "NOT_FOUND", message: "Réservation introuvable" });
    }

    // Only carrier can change truck
    if (booking.carrierId !== user.userId && !isPortAdmin(user)) {
      throw new ConvexError({ code: "FORBIDDEN", message: "Accès refusé" });
    }

    if (booking.status !== "pending" && booking.status !== "confirmed") {
      throw new ConvexError({
        code: "INVALID_STATE",
        message: `Impossible de changer le camion pour une réservation avec le statut "${booking.status}"`,
      });
    }

    // Validate new truck
    const newTruck = await ctx.db.get(args.newTruckId);
    if (!newTruck || !newTruck.isActive) {
      throw new ConvexError({ code: "NOT_FOUND", message: "Camion introuvable" });
    }
    if (newTruck.ownerId !== user.userId) {
      throw new ConvexError({
        code: "FORBIDDEN",
        message: "Ce camion ne vous appartient pas",
      });
    }

    // If already confirmed with gate, validate truck compatibility
    if (booking.gateId) {
      const gate = await ctx.db.get(booking.gateId);
      if (gate) {
        if (!gate.allowedTruckTypes.includes(newTruck.truckType)) {
          throw new ConvexError({
            code: "INVALID_INPUT",
            message: `Le type de camion ${newTruck.truckType} n'est pas accepté à cette porte`,
          });
        }
        if (!gate.allowedTruckClasses.includes(newTruck.truckClass)) {
          throw new ConvexError({
            code: "INVALID_INPUT",
            message: `La classe de camion ${newTruck.truckClass} n'est pas acceptée à cette porte`,
          });
        }
      }
    }

    // Check new truck doesn't have booking for same slot
    const existingBooking = await ctx.db
      .query("bookings")
      .withIndex("by_truck", q => q.eq("truckId", args.newTruckId))
      .filter(q =>
        q.and(
          q.eq(q.field("preferredDate"), booking.preferredDate),
          q.eq(q.field("preferredTimeStart"), booking.preferredTimeStart),
          q.neq(q.field("_id"), args.bookingId),
          q.or(
            q.eq(q.field("status"), "pending"),
            q.eq(q.field("status"), "confirmed")
          )
        )
      )
      .first();

    if (existingBooking) {
      throw new ConvexError({
        code: "DUPLICATE",
        message: "Ce camion a déjà une réservation pour ce créneau",
      });
    }

    const previousTruckId = booking.truckId;

    await ctx.db.patch(args.bookingId, {
      truckId: args.newTruckId,
      updatedAt: Date.now(),
    });

    await ctx.runMutation(internal.bookings.internal.recordHistory, {
      bookingId: args.bookingId,
      changeType: "truck_changed",
      previousValue: previousTruckId,
      newValue: args.newTruckId,
      changedBy: user.userId,
      requiredRebook: false,
    });

    return null;
  },
});
```

---

## Phase 3: AI Tools (French Only)

### 3.1 Updated Agent Configuration

**File: `packages/backend/convex/ai/agent.ts` (REPLACE)**

```typescript
"use node";
import { google } from "@ai-sdk/google";
import { Agent } from "@convex-dev/agent";
import { components } from "../_generated/api";
import { ALL_TOOLS } from "./registry";

export const apcsAgent = new Agent(components.agent, {
  name: "Assistant APCS",
  languageModel: google("gemini-2.0-flash"),
  instructions: `Tu es l'assistant APCS (Advanced Port Container System).
Tu aides les utilisateurs à gérer les opérations portuaires, les réservations de camions et la logistique.

IMPORTANT: Tu réponds TOUJOURS en français, quelle que soit la langue de l'utilisateur.

Informations clés:
- Le système gère des terminaux portuaires avec des portes d'entrée
- Les réservations sont faites au niveau du terminal, pas de la porte
- Une réservation = 1 camion + plusieurs conteneurs (enlèvement ou dépôt)
- Il y a trois rôles: port_admin, terminal_operator, carrier
- Cycle de vie des réservations: en_attente → confirmée/refusée → consommée/annulée/expirée

Règles:
- Utilise TOUJOURS les outils disponibles pour récupérer des données réelles
- Ne jamais inventer d'informations
- Présente les données de manière claire et structurée
- Si un outil retourne ACCESS_DENIED, explique que le rôle de l'utilisateur ne permet pas cette action
- Sois concis mais complet
- Pour les réservations, guide l'utilisateur étape par étape:
  1. D'abord sélectionner les conteneurs
  2. Ensuite choisir un créneau optimal
  3. Puis sélectionner le camion
  4. Enfin confirmer la réservation

Validation automatique:
- Les premières réservations d'un créneau peuvent être validées automatiquement
- Si la réservation est auto-validée, informe l'utilisateur que sa réservation est confirmée immédiatement
- Sinon, explique que la réservation est en attente de validation par l'opérateur`,
  tools: ALL_TOOLS,
  maxSteps: 10,
});
```

### 3.2 New AI Tools for Containers

**File: `packages/backend/convex/ai/tools/containers.ts` (CREATE)**

```typescript
import { tool } from "@convex-dev/agent";
import { v } from "convex/values";
import { internal } from "../../_generated/api";
import { checkToolAccess } from "./types";

/**
 * List carrier's containers
 */
export const listMyContainers = tool({
  description: "Liste les conteneurs du transporteur avec filtres optionnels",
  args: {
    operationType: v.optional(v.union(v.literal("pick_up"), v.literal("drop_off"))),
    includeBooked: v.optional(v.boolean()),
  },
  returns: v.object({
    containers: v.array(v.object({
      id: v.string(),
      containerNumber: v.string(),
      type: v.string(),
      dimensions: v.string(),
      operationType: v.string(),
      isEmpty: v.boolean(),
      isBooked: v.boolean(),
    })),
    total: v.number(),
  }),
  handler: async (ctx, args) => {
    const accessCheck = await checkToolAccess(ctx, "listMyContainers");
    if (!accessCheck.allowed) {
      return { containers: [], total: 0 };
    }

    const containers = await ctx.runQuery(internal.ai.internalQueries.listMyContainers, {
      operationType: args.operationType,
      includeBooked: args.includeBooked ?? false,
    });

    return {
      containers: containers.map(c => ({
        id: c._id,
        containerNumber: c.containerNumber,
        type: c.containerType,
        dimensions: c.dimensions,
        operationType: c.operationType,
        isEmpty: c.isEmpty,
        isBooked: !!c.bookingId,
      })),
      total: containers.length,
    };
  },
});

/**
 * Interactive container selector for booking
 */
export const selectContainersForBooking = tool({
  description: "Affiche un sélecteur interactif de conteneurs pour la réservation",
  args: {
    operationType: v.optional(v.union(v.literal("pick_up"), v.literal("drop_off"))),
  },
  returns: v.object({
    uiComponent: v.string(),
    availableContainers: v.array(v.object({
      id: v.string(),
      containerNumber: v.string(),
      type: v.string(),
      dimensions: v.string(),
      operationType: v.string(),
    })),
  }),
  handler: async (ctx, args) => {
    const accessCheck = await checkToolAccess(ctx, "selectContainersForBooking");
    if (!accessCheck.allowed) {
      return { uiComponent: "access_denied", availableContainers: [] };
    }

    const containers = await ctx.runQuery(internal.ai.internalQueries.listMyContainers, {
      operationType: args.operationType,
      includeBooked: false,
    });

    return {
      uiComponent: "container-selector",
      availableContainers: containers.map(c => ({
        id: c._id,
        containerNumber: c.containerNumber,
        type: c.containerType,
        dimensions: c.dimensions,
        operationType: c.operationType,
      })),
    };
  },
});
```

### 3.3 New AI Tools for Slots

**File: `packages/backend/convex/ai/tools/slots.ts` (CREATE)**

```typescript
import { tool } from "@convex-dev/agent";
import { v } from "convex/values";
import { internal } from "../../_generated/api";
import { checkToolAccess } from "./types";

/**
 * Get slot availability with capacity info
 */
export const getSlotAvailability = tool({
  description: "Récupère la disponibilité des créneaux pour un terminal et une date",
  args: {
    terminalId: v.string(),
    date: v.string(),                             // YYYY-MM-DD
  },
  returns: v.object({
    uiComponent: v.string(),
    slots: v.array(v.object({
      startTime: v.string(),
      endTime: v.string(),
      available: v.number(),
      total: v.number(),
      utilizationPercent: v.number(),
      canAutoValidate: v.boolean(),
    })),
  }),
  handler: async (ctx, args) => {
    const accessCheck = await checkToolAccess(ctx, "getSlotAvailability");
    if (!accessCheck.allowed) {
      return { uiComponent: "access_denied", slots: [] };
    }

    const slots = await ctx.runQuery(internal.ai.internalQueries.getSlotAvailability, {
      terminalId: args.terminalId,
      date: args.date,
    });

    return {
      uiComponent: "slot-calendar",
      slots: slots.map(s => ({
        startTime: s.startTime,
        endTime: s.endTime,
        available: s.available,
        total: s.total,
        utilizationPercent: s.utilizationPercent,
        canAutoValidate: s.remainingAutoValidation > 0,
      })),
    };
  },
});

/**
 * Suggest optimal slots based on load balancing and urgency
 */
export const suggestOptimalSlots = tool({
  description: "Suggère les meilleurs créneaux en fonction de la charge et des conteneurs sélectionnés",
  args: {
    terminalId: v.string(),
    containerIds: v.array(v.string()),
    preferredDate: v.optional(v.string()),
  },
  returns: v.object({
    uiComponent: v.string(),
    suggestions: v.array(v.object({
      date: v.string(),
      startTime: v.string(),
      endTime: v.string(),
      score: v.number(),                          // 0-100 recommendation score
      reason: v.string(),
      canAutoValidate: v.boolean(),
    })),
  }),
  handler: async (ctx, args) => {
    const accessCheck = await checkToolAccess(ctx, "suggestOptimalSlots");
    if (!accessCheck.allowed) {
      return { uiComponent: "access_denied", suggestions: [] };
    }

    const suggestions = await ctx.runQuery(internal.ai.internalQueries.suggestOptimalSlots, {
      terminalId: args.terminalId,
      containerIds: args.containerIds,
      preferredDate: args.preferredDate,
    });

    return {
      uiComponent: "slot-suggestions",
      suggestions: suggestions.map(s => ({
        date: s.date,
        startTime: s.startTime,
        endTime: s.endTime,
        score: s.score,
        reason: s.reason,
        canAutoValidate: s.canAutoValidate,
      })),
    };
  },
});
```

### 3.4 New AI Tools for Booking Flow

**File: `packages/backend/convex/ai/tools/booking-flow.ts` (CREATE)**

```typescript
import { tool } from "@convex-dev/agent";
import { v } from "convex/values";
import { internal } from "../../_generated/api";
import { checkToolAccess } from "./types";

/**
 * Create booking via AI
 */
export const createBookingViaAI = tool({
  description: "Crée une réservation avec les conteneurs et le créneau sélectionnés",
  args: {
    terminalId: v.string(),
    truckId: v.string(),
    containerIds: v.array(v.string()),
    preferredDate: v.string(),
    preferredTimeStart: v.string(),
    preferredTimeEnd: v.string(),
    driverName: v.optional(v.string()),
    driverPhone: v.optional(v.string()),
  },
  returns: v.object({
    success: v.boolean(),
    uiComponent: v.string(),
    booking: v.optional(v.object({
      bookingId: v.string(),
      bookingReference: v.string(),
      status: v.string(),
      wasAutoValidated: v.boolean(),
      gateName: v.optional(v.string()),
    })),
    error: v.optional(v.string()),
  }),
  handler: async (ctx, args) => {
    const accessCheck = await checkToolAccess(ctx, "createBookingViaAI");
    if (!accessCheck.allowed) {
      return { 
        success: false, 
        uiComponent: "access_denied",
        error: "Accès refusé" 
      };
    }

    try {
      const result = await ctx.runMutation(internal.ai.mutations.createBooking, {
        terminalId: args.terminalId,
        truckId: args.truckId,
        containerIds: args.containerIds,
        preferredDate: args.preferredDate,
        preferredTimeStart: args.preferredTimeStart,
        preferredTimeEnd: args.preferredTimeEnd,
        driverName: args.driverName,
        driverPhone: args.driverPhone,
      });

      return {
        success: true,
        uiComponent: "booking-confirmation-card",
        booking: {
          bookingId: result.bookingId,
          bookingReference: result.bookingReference,
          status: result.status,
          wasAutoValidated: result.wasAutoValidated,
          gateName: result.gateName,
        },
      };
    } catch (error: any) {
      return {
        success: false,
        uiComponent: "error",
        error: error.message || "Erreur lors de la création de la réservation",
      };
    }
  },
});

/**
 * Cancel booking via AI
 */
export const cancelBookingViaAI = tool({
  description: "Annule une réservation existante",
  args: {
    bookingId: v.string(),
    reason: v.optional(v.string()),
  },
  returns: v.object({
    success: v.boolean(),
    message: v.string(),
  }),
  handler: async (ctx, args) => {
    const accessCheck = await checkToolAccess(ctx, "cancelBookingViaAI");
    if (!accessCheck.allowed) {
      return { success: false, message: "Accès refusé" };
    }

    try {
      await ctx.runMutation(internal.ai.mutations.cancelBooking, {
        bookingId: args.bookingId,
        reason: args.reason,
      });

      return {
        success: true,
        message: "Réservation annulée avec succès",
      };
    } catch (error: any) {
      return {
        success: false,
        message: error.message || "Erreur lors de l'annulation",
      };
    }
  },
});

/**
 * Change truck for booking via AI
 */
export const changeTruckViaAI = tool({
  description: "Change le camion assigné à une réservation",
  args: {
    bookingId: v.string(),
    newTruckId: v.string(),
  },
  returns: v.object({
    success: v.boolean(),
    message: v.string(),
  }),
  handler: async (ctx, args) => {
    const accessCheck = await checkToolAccess(ctx, "changeTruckViaAI");
    if (!accessCheck.allowed) {
      return { success: false, message: "Accès refusé" };
    }

    try {
      await ctx.runMutation(internal.ai.mutations.changeTruck, {
        bookingId: args.bookingId,
        newTruckId: args.newTruckId,
      });

      return {
        success: true,
        message: "Camion changé avec succès",
      };
    } catch (error: any) {
      return {
        success: false,
        message: error.message || "Erreur lors du changement de camion",
      };
    }
  },
});
```

### 3.5 New AI Tools for Trucks

**File: `packages/backend/convex/ai/tools/trucks.ts` (CREATE)**

```typescript
import { tool } from "@convex-dev/agent";
import { v } from "convex/values";
import { internal } from "../../_generated/api";
import { checkToolAccess } from "./types";

/**
 * List carrier's trucks
 */
export const listMyTrucks = tool({
  description: "Liste les camions du transporteur",
  args: {},
  returns: v.object({
    trucks: v.array(v.object({
      id: v.string(),
      licensePlate: v.string(),
      truckType: v.string(),
      truckClass: v.string(),
      make: v.optional(v.string()),
      model: v.optional(v.string()),
    })),
    total: v.number(),
  }),
  handler: async (ctx, args) => {
    const accessCheck = await checkToolAccess(ctx, "listMyTrucks");
    if (!accessCheck.allowed) {
      return { trucks: [], total: 0 };
    }

    const trucks = await ctx.runQuery(internal.ai.internalQueries.listMyTrucks, {});

    return {
      trucks: trucks.map(t => ({
        id: t._id,
        licensePlate: t.licensePlate,
        truckType: t.truckType,
        truckClass: t.truckClass,
        make: t.make,
        model: t.model,
      })),
      total: trucks.length,
    };
  },
});
```

### 3.6 Updated Tool Permissions

**File: `packages/backend/convex/ai/tools/types.ts` (UPDATE)**

```typescript
export const TOOL_PERMISSIONS: Record<string, ApcsRole[]> = {
  // Existing tools
  listMyBookings: ["carrier", "terminal_operator", "port_admin"],
  getBookingDetails: ["carrier", "terminal_operator", "port_admin"],
  listBookingsByTerminal: ["terminal_operator", "port_admin"],
  listBookingsByCarrier: ["port_admin"],
  listPendingBookings: ["terminal_operator", "port_admin"],
  listTerminals: ["carrier", "terminal_operator", "port_admin"],
  getTerminalDetails: ["carrier", "terminal_operator", "port_admin"],
  getAvailableSlots: ["carrier", "terminal_operator", "port_admin"],
  getSystemConfig: ["carrier", "terminal_operator", "port_admin"],

  // NEW: Container tools
  listMyContainers: ["carrier"],
  selectContainersForBooking: ["carrier"],

  // NEW: Slot tools
  getSlotAvailability: ["carrier", "terminal_operator", "port_admin"],
  suggestOptimalSlots: ["carrier"],

  // NEW: Booking flow tools
  createBookingViaAI: ["carrier"],
  cancelBookingViaAI: ["carrier"],
  changeTruckViaAI: ["carrier"],

  // NEW: Truck tools
  listMyTrucks: ["carrier"],
};
```

### 3.7 Updated Registry

**File: `packages/backend/convex/ai/registry.ts` (UPDATE)**

```typescript
// Add new imports
import { listMyContainers, selectContainersForBooking } from "./tools/containers";
import { getSlotAvailability, suggestOptimalSlots } from "./tools/slots";
import { createBookingViaAI, cancelBookingViaAI, changeTruckViaAI } from "./tools/booking-flow";
import { listMyTrucks } from "./tools/trucks";

export const ALL_TOOLS = {
  // Existing
  listMyBookings,
  getBookingDetails,
  listBookingsByTerminal,
  listBookingsByCarrier,
  listPendingBookings,
  listTerminals,
  getTerminalDetails,
  getAvailableSlots,
  getSystemConfig,

  // NEW: Containers
  listMyContainers,
  selectContainersForBooking,

  // NEW: Slots
  getSlotAvailability,
  suggestOptimalSlots,

  // NEW: Booking flow
  createBookingViaAI,
  cancelBookingViaAI,
  changeTruckViaAI,

  // NEW: Trucks
  listMyTrucks,
} as const;
```

---

## Phase 4: QR Code System

**File: `packages/backend/convex/qr/index.ts` (CREATE)**

```typescript
"use node";
import { internalAction, internalMutation } from "../_generated/server";
import { v } from "convex/values";
import QRCode from "qrcode";

/**
 * Generate QR code for a booking
 */
export const generateQRCode = internalAction({
  args: {
    bookingId: v.id("bookings"),
  },
  returns: v.object({
    success: v.boolean(),
    qrCode: v.optional(v.string()),
    storageId: v.optional(v.id("_storage")),
  }),
  handler: async (ctx, args) => {
    const booking = await ctx.runQuery(internal.bookings.queries.get, {
      bookingId: args.bookingId,
    });

    if (!booking) {
      return { success: false };
    }

    // Generate QR code data URL
    const qrData = JSON.stringify({
      type: "APCS_BOOKING",
      ref: booking.bookingReference,
    });

    try {
      const qrCodeDataUrl = await QRCode.toDataURL(qrData, {
        width: 300,
        margin: 2,
        color: {
          dark: "#000000",
          light: "#FFFFFF",
        },
      });

      // Also generate as buffer for file storage
      const qrCodeBuffer = await QRCode.toBuffer(qrData, {
        width: 300,
        margin: 2,
      });

      // Store in Convex file storage
      const blob = new Blob([qrCodeBuffer], { type: "image/png" });
      const storageId = await ctx.storage.store(blob);

      // Update booking with QR code
      await ctx.runMutation(internal.qr.updateBookingQR, {
        bookingId: args.bookingId,
        qrCode: qrCodeDataUrl,
        qrCodeStorageId: storageId,
      });

      return {
        success: true,
        qrCode: qrCodeDataUrl,
        storageId,
      };
    } catch (error) {
      console.error("QR code generation failed:", error);
      return { success: false };
    }
  },
});

export const updateBookingQR = internalMutation({
  args: {
    bookingId: v.id("bookings"),
    qrCode: v.string(),
    qrCodeStorageId: v.id("_storage"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.patch(args.bookingId, {
      qrCode: args.qrCode,
      qrCodeStorageId: args.qrCodeStorageId,
      updatedAt: Date.now(),
    });
    return null;
  },
});
```

**File: `packages/backend/convex/qr/scan.ts` (CREATE)**

```typescript
import { mutation } from "../_generated/server";
import { v, ConvexError } from "convex/values";
import { getAuthenticatedUser, requireRole, canManageTerminal } from "../lib/permissions";
import { internal } from "../_generated/api";

/**
 * Scan types
 */
export const scanTypeValidator = v.union(
  v.literal("entry"),
  v.literal("exit")
);

/**
 * Process QR code scan (entry or exit)
 */
export const processScan = mutation({
  args: {
    bookingReference: v.string(),
    scanType: scanTypeValidator,
    gateId: v.id("gates"),
  },
  returns: v.object({
    success: v.boolean(),
    message: v.string(),
    booking: v.optional(v.object({
      bookingReference: v.string(),
      truckLicensePlate: v.string(),
      driverName: v.optional(v.string()),
      containerCount: v.number(),
      status: v.string(),
    })),
  }),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);
    requireRole(user, ["terminal_operator", "port_admin"]);

    // Find booking by reference
    const booking = await ctx.db
      .query("bookings")
      .withIndex("by_reference", q => q.eq("bookingReference", args.bookingReference))
      .first();

    if (!booking) {
      return {
        success: false,
        message: `Réservation ${args.bookingReference} introuvable`,
      };
    }

    // Verify gate belongs to booking's terminal
    const gate = await ctx.db.get(args.gateId);
    if (!gate || gate.terminalId !== booking.terminalId) {
      return {
        success: false,
        message: "Cette porte n'appartient pas au terminal de la réservation",
      };
    }

    // Verify operator has access to terminal
    const hasAccess = await canManageTerminal(ctx, user, booking.terminalId);
    if (!hasAccess) {
      return {
        success: false,
        message: "Vous n'avez pas accès à ce terminal",
      };
    }

    // Get truck info
    const truck = await ctx.db.get(booking.truckId);

    // Process based on scan type
    if (args.scanType === "entry") {
      // Entry scan
      if (booking.status !== "confirmed") {
        return {
          success: false,
          message: `Impossible de scanner l'entrée - statut actuel: ${booking.status}`,
        };
      }

      if (booking.entryScannedAt) {
        return {
          success: false,
          message: "Cette réservation a déjà été scannée à l'entrée",
        };
      }

      const now = Date.now();
      await ctx.db.patch(booking._id, {
        status: "consumed",
        consumedAt: now,
        entryScannedAt: now,
        scannedByEntry: user.userId,
        gateId: args.gateId, // Update gate to actual entry gate
        updatedAt: now,
      });

      // Record history
      await ctx.runMutation(internal.bookings.internal.recordHistory, {
        bookingId: booking._id,
        changeType: "status_changed",
        previousValue: "confirmed",
        newValue: "consumed",
        changedBy: user.userId,
        note: `Entrée scannée à la porte ${gate.name}`,
        requiredRebook: false,
      });

      return {
        success: true,
        message: `Entrée validée - Bienvenue au terminal`,
        booking: {
          bookingReference: booking.bookingReference,
          truckLicensePlate: truck?.licensePlate ?? "Inconnu",
          driverName: booking.driverName,
          containerCount: booking.containerIds.length,
          status: "consumed",
        },
      };
    } else {
      // Exit scan
      if (booking.status !== "consumed") {
        return {
          success: false,
          message: `Impossible de scanner la sortie - statut actuel: ${booking.status}`,
        };
      }

      if (!booking.entryScannedAt) {
        return {
          success: false,
          message: "Aucun scan d'entrée enregistré pour cette réservation",
        };
      }

      if (booking.exitScannedAt) {
        return {
          success: false,
          message: "Cette réservation a déjà été scannée à la sortie",
        };
      }

      const now = Date.now();
      await ctx.db.patch(booking._id, {
        exitScannedAt: now,
        scannedByExit: user.userId,
        updatedAt: now,
      });

      // Calculate time in terminal
      const timeInTerminalMs = now - booking.entryScannedAt;
      const timeInTerminalMinutes = Math.round(timeInTerminalMs / 60000);

      return {
        success: true,
        message: `Sortie validée - Temps dans le terminal: ${timeInTerminalMinutes} minutes`,
        booking: {
          bookingReference: booking.bookingReference,
          truckLicensePlate: truck?.licensePlate ?? "Inconnu",
          driverName: booking.driverName,
          containerCount: booking.containerIds.length,
          status: "consumed",
        },
      };
    }
  },
});
```

---

## Phase 5: Notification System with Email

**File: `packages/backend/convex/email/index.ts` (CREATE)**

```typescript
"use node";
import { internalAction } from "../_generated/server";
import { v } from "convex/values";
import { Resend } from "resend";

const resend = new Resend(process.env.RESEND_API_KEY);

/**
 * Send email notification
 */
export const sendEmail = internalAction({
  args: {
    to: v.string(),
    subject: v.string(),
    html: v.string(),
  },
  returns: v.object({
    success: v.boolean(),
    messageId: v.optional(v.string()),
    error: v.optional(v.string()),
  }),
  handler: async (ctx, args) => {
    try {
      const result = await resend.emails.send({
        from: "APCS <noreply@apcs.port>",
        to: args.to,
        subject: args.subject,
        html: args.html,
      });

      return {
        success: true,
        messageId: result.data?.id,
      };
    } catch (error: any) {
      console.error("Email send failed:", error);
      return {
        success: false,
        error: error.message,
      };
    }
  },
});

/**
 * French email templates
 */
export const EMAIL_TEMPLATES = {
  booking_created: (params: {
    reference: string;
    terminal: string;
    date: string;
    time: string;
  }) => ({
    subject: `Réservation ${params.reference} créée`,
    html: `
      <h1>Réservation créée</h1>
      <p>Votre réservation <strong>${params.reference}</strong> a été créée.</p>
      <ul>
        <li><strong>Terminal:</strong> ${params.terminal}</li>
        <li><strong>Date:</strong> ${params.date}</li>
        <li><strong>Heure:</strong> ${params.time}</li>
      </ul>
      <p>Elle est en attente de confirmation par l'opérateur.</p>
    `,
  }),

  booking_confirmed: (params: {
    reference: string;
    terminal: string;
    gate: string;
    date: string;
    time: string;
    qrCodeUrl?: string;
  }) => ({
    subject: `Réservation ${params.reference} confirmée`,
    html: `
      <h1>Réservation confirmée</h1>
      <p>Votre réservation <strong>${params.reference}</strong> a été confirmée.</p>
      <ul>
        <li><strong>Terminal:</strong> ${params.terminal}</li>
        <li><strong>Porte:</strong> ${params.gate}</li>
        <li><strong>Date:</strong> ${params.date}</li>
        <li><strong>Heure:</strong> ${params.time}</li>
      </ul>
      ${params.qrCodeUrl ? `<p>Présentez ce QR code à l'entrée:</p><img src="${params.qrCodeUrl}" alt="QR Code" />` : ""}
    `,
  }),

  booking_rejected: (params: {
    reference: string;
    reason: string;
  }) => ({
    subject: `Réservation ${params.reference} refusée`,
    html: `
      <h1>Réservation refusée</h1>
      <p>Votre réservation <strong>${params.reference}</strong> a été refusée.</p>
      <p><strong>Raison:</strong> ${params.reason}</p>
      <p>Veuillez créer une nouvelle réservation avec les corrections nécessaires.</p>
    `,
  }),

  booking_reminder: (params: {
    reference: string;
    terminal: string;
    gate: string;
    hoursUntil: number;
  }) => ({
    subject: `Rappel: Réservation ${params.reference} dans ${params.hoursUntil}h`,
    html: `
      <h1>Rappel de réservation</h1>
      <p>Votre réservation <strong>${params.reference}</strong> est prévue dans <strong>${params.hoursUntil} heures</strong>.</p>
      <ul>
        <li><strong>Terminal:</strong> ${params.terminal}</li>
        <li><strong>Porte:</strong> ${params.gate}</li>
      </ul>
      <p>N'oubliez pas votre QR code!</p>
    `,
  }),

  capacity_alert: (params: {
    terminal: string;
    date: string;
    utilizationPercent: number;
  }) => ({
    subject: `Alerte capacité: ${params.terminal} à ${params.utilizationPercent}%`,
    html: `
      <h1>Alerte de capacité</h1>
      <p>Le terminal <strong>${params.terminal}</strong> atteint <strong>${params.utilizationPercent}%</strong> de sa capacité pour le ${params.date}.</p>
      <p>Veuillez surveiller les réservations et ajuster la capacité si nécessaire.</p>
    `,
  }),
};
```

---

## Phase 6: Cron Jobs

**File: `packages/backend/convex/crons.ts` (UPDATE)**

```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// ============================================================================
// BOOKING EXPIRATION (with grace period)
// ============================================================================

crons.interval(
  "expire old bookings with grace period",
  { minutes: 15 },
  internal.scheduled.expireBookingsWithGrace,
  {}
);

// ============================================================================
// BOOKING REMINDERS
// ============================================================================

crons.interval(
  "send 24h booking reminders",
  { hours: 1 },
  internal.scheduled.sendBookingReminders,
  { hoursBeforeSlot: 24 }
);

crons.interval(
  "send 2h booking reminders",
  { minutes: 30 },
  internal.scheduled.sendBookingReminders,
  { hoursBeforeSlot: 2 }
);

// ============================================================================
// CAPACITY ALERTS
// ============================================================================

crons.cron(
  "check capacity alerts",
  "0 6,12,18 * * *",  // 6am, 12pm, 6pm
  internal.scheduled.checkCapacityAlerts,
  {}
);

// ============================================================================
// ANALYTICS AGGREGATION
// ============================================================================

crons.cron(
  "hourly analytics aggregation",
  "0 * * * *",  // Every hour
  internal.scheduled.computeHourlyAggregates,
  {}
);

crons.cron(
  "daily analytics rollup",
  "0 1 * * *",  // 1am daily
  internal.scheduled.computeDailyAggregates,
  {}
);

// ============================================================================
// CLEANUP
// ============================================================================

crons.cron(
  "cleanup old notifications",
  "0 2 * * *",
  internal.scheduled.cleanupOldNotifications,
  { daysToKeep: 30 }
);

crons.cron(
  "cleanup old audit logs",
  "0 3 * * 0",  // Sunday 3am
  internal.scheduled.cleanupOldAuditLogs,
  { daysToKeep: 90 }
);

crons.cron(
  "recalculate slot capacity",
  "0 4 * * *",
  internal.scheduled.recalculateAllCapacity,
  {}
);

export default crons;
```

---

## Phase 7: Audit Logging

**File: `packages/backend/convex/lib/auditLog.ts` (CREATE)**

```typescript
import type { MutationCtx } from "../_generated/server";
import type { AuditAction } from "./validators";

interface AuditLogParams {
  userId?: string;
  action: AuditAction;
  resource: string;
  resourceId?: string;
  args?: Record<string, unknown>;
  result?: string;
  errorMessage?: string;
  ipAddress?: string;
  userAgent?: string;
  sessionId?: string;
  aiThreadId?: string;
  aiToolName?: string;
  durationMs?: number;
}

// Fields to redact from audit logs
const SENSITIVE_FIELDS = [
  "password",
  "token",
  "secret",
  "apiKey",
  "api_key",
  "authorization",
  "credit_card",
  "ssn",
];

/**
 * Sanitize args by redacting sensitive fields
 */
function sanitizeArgs(args: Record<string, unknown>): Record<string, unknown> {
  const sanitized: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(args)) {
    const keyLower = key.toLowerCase();
    if (SENSITIVE_FIELDS.some(f => keyLower.includes(f))) {
      sanitized[key] = "[REDACTED]";
    } else if (typeof value === "object" && value !== null) {
      sanitized[key] = sanitizeArgs(value as Record<string, unknown>);
    } else {
      sanitized[key] = value;
    }
  }

  return sanitized;
}

/**
 * Log an audit entry
 */
export async function logAudit(
  ctx: MutationCtx,
  params: AuditLogParams
): Promise<void> {
  await ctx.db.insert("auditLogs", {
    userId: params.userId,
    action: params.action,
    resource: params.resource,
    resourceId: params.resourceId,
    args: params.args ? JSON.stringify(sanitizeArgs(params.args)) : undefined,
    result: params.result,
    errorMessage: params.errorMessage,
    ipAddress: params.ipAddress,
    userAgent: params.userAgent,
    sessionId: params.sessionId,
    aiThreadId: params.aiThreadId,
    aiToolName: params.aiToolName,
    timestamp: Date.now(),
    durationMs: params.durationMs,
  });
}
```

**File: `packages/backend/convex/lib/withAudit.ts` (CREATE)**

```typescript
import type { MutationCtx } from "../_generated/server";
import { logAudit } from "./auditLog";

/**
 * Wrapper to add audit logging to mutations
 */
export function withAudit<TArgs, TResult>(
  resource: string,
  handler: (ctx: MutationCtx, args: TArgs) => Promise<TResult>
) {
  return async (ctx: MutationCtx, args: TArgs): Promise<TResult> => {
    const startTime = Date.now();
    let result: string = "success";
    let errorMessage: string | undefined;

    try {
      const handlerResult = await handler(ctx, args);
      return handlerResult;
    } catch (error: any) {
      result = `error:${error.code || "UNKNOWN"}`;
      errorMessage = error.message;
      throw error;
    } finally {
      const durationMs = Date.now() - startTime;

      // Get user ID from auth context (simplified)
      let userId: string | undefined;
      try {
        const identity = await ctx.auth.getUserIdentity();
        userId = identity?.subject;
      } catch {
        // No auth context
      }

      await logAudit(ctx, {
        userId,
        action: "mutation",
        resource,
        args: args as Record<string, unknown>,
        result,
        errorMessage,
        durationMs,
      });
    }
  };
}
```

---

## Phase 8: Seed Data Generation

**File: `packages/backend/convex/seed/index.ts` (CREATE)**

```typescript
import { internalMutation } from "../_generated/server";
import { v } from "convex/values";
import { generateTerminals } from "./terminals";
import { generateContainers } from "./containers";
import { generateUsers } from "./users";

/**
 * Main seed function - run manually from dashboard
 */
export const seedAll = internalMutation({
  args: {
    clearExisting: v.optional(v.boolean()),
  },
  returns: v.object({
    terminals: v.number(),
    gates: v.number(),
    timeSlots: v.number(),
    carriers: v.number(),
    trucks: v.number(),
    containers: v.number(),
    operators: v.number(),
  }),
  handler: async (ctx, args) => {
    if (args.clearExisting) {
      // Clear all data (careful in production!)
      // ... implementation
    }

    // Generate in order
    const terminalResults = await generateTerminals(ctx);
    const userResults = await generateUsers(ctx, terminalResults.terminals);
    const containerResults = await generateContainers(ctx, userResults.carriers);

    return {
      terminals: terminalResults.count,
      gates: terminalResults.gateCount,
      timeSlots: terminalResults.slotCount,
      carriers: userResults.carrierCount,
      trucks: userResults.truckCount,
      containers: containerResults.count,
      operators: userResults.operatorCount,
    };
  },
});
```

**File: `packages/backend/convex/seed/containers.ts` (CREATE)**

```typescript
import type { MutationCtx } from "../_generated/server";

// ISO 6346 owner codes (fictional)
const OWNER_CODES = ["MSCU", "MAEU", "CMAU", "HLCU", "OOLU", "COSU", "EITU", "TCNU"];

// Container type distribution
const TYPE_DISTRIBUTION = {
  dry: 0.60,
  reefer: 0.15,
  open_top: 0.08,
  flat_rack: 0.07,
  tank: 0.05,
  hazardous: 0.05,
};

// Dimension distribution
const DIMENSION_DISTRIBUTION = {
  "20ft": 0.35,
  "40ft": 0.40,
  "40ft_hc": 0.20,
  "45ft": 0.05,
};

/**
 * Generate ISO 6346 compliant container number
 */
function generateContainerNumber(ownerCode: string, index: number): string {
  const serial = index.toString().padStart(6, "0");
  // Simplified check digit (not real ISO calculation)
  const checkDigit = (index % 10).toString();
  return `${ownerCode}${serial}${checkDigit}`;
}

/**
 * Select from weighted distribution
 */
function selectFromDistribution<T extends string>(
  distribution: Record<T, number>
): T {
  const rand = Math.random();
  let cumulative = 0;
  for (const [key, weight] of Object.entries(distribution)) {
    cumulative += weight as number;
    if (rand <= cumulative) {
      return key as T;
    }
  }
  return Object.keys(distribution)[0] as T;
}

export async function generateContainers(
  ctx: MutationCtx,
  carriers: { userId: string }[]
): Promise<{ count: number }> {
  const TARGET_CONTAINERS = 750;
  const containersPerCarrier = Math.ceil(TARGET_CONTAINERS / carriers.length);

  let totalCount = 0;
  let containerIndex = 1;

  for (const carrier of carriers) {
    const ownerCode = OWNER_CODES[Math.floor(Math.random() * OWNER_CODES.length)];

    for (let i = 0; i < containersPerCarrier && totalCount < TARGET_CONTAINERS; i++) {
      const containerType = selectFromDistribution(TYPE_DISTRIBUTION);
      const dimensions = selectFromDistribution(DIMENSION_DISTRIBUTION);
      
      // 70% drop-off, 30% pick-up
      const operationType = Math.random() < 0.7 ? "drop_off" : "pick_up";
      
      // 30% empty
      const isEmpty = Math.random() < 0.3;
      
      // Weight class based on type and empty status
      let weightClass: "light" | "medium" | "heavy" | "super_heavy";
      if (isEmpty) {
        weightClass = "light";
      } else if (containerType === "hazardous" || containerType === "tank") {
        weightClass = Math.random() < 0.5 ? "heavy" : "super_heavy";
      } else {
        weightClass = selectFromDistribution({
          light: 0.2,
          medium: 0.4,
          heavy: 0.3,
          super_heavy: 0.1,
        });
      }

      const now = Date.now();
      await ctx.db.insert("containers", {
        ownerId: carrier.userId,
        containerNumber: generateContainerNumber(ownerCode, containerIndex++),
        containerType,
        dimensions,
        weightClass,
        operationType,
        isEmpty,
        isActive: true,
        readyDate: operationType === "pick_up" 
          ? now + Math.random() * 7 * 24 * 60 * 60 * 1000 
          : undefined,
        departureDate: operationType === "drop_off"
          ? now + Math.random() * 14 * 24 * 60 * 60 * 1000
          : undefined,
        createdAt: now,
        updatedAt: now,
      });

      totalCount++;
    }
  }

  return { count: totalCount };
}
```

---

## Phase 9: Analytics

**File: `packages/backend/convex/analytics/compute.ts` (CREATE)**

```typescript
import { internalMutation } from "../_generated/server";
import { v } from "convex/values";

/**
 * Compute hourly aggregates for all terminals
 */
export const computeHourlyAggregates = internalMutation({
  args: {},
  returns: v.number(), // Count of aggregates created
  handler: async (ctx) => {
    const now = new Date();
    const currentHour = now.getUTCHours();
    const dateStr = now.toISOString().slice(0, 10);

    const terminals = await ctx.db.query("terminals").collect();
    let count = 0;

    for (const terminal of terminals) {
      // Get all bookings for this terminal, date, and hour
      const bookings = await ctx.db
        .query("bookings")
        .withIndex("by_terminal_and_date", q =>
          q.eq("terminalId", terminal._id).eq("preferredDate", dateStr)
        )
        .collect();

      // Filter to current hour
      const hourBookings = bookings.filter(b => {
        const hour = parseInt(b.preferredTimeStart.split(":")[0], 10);
        return hour === currentHour;
      });

      // Compute metrics
      const metrics = {
        totalBookings: hourBookings.length,
        pendingCount: hourBookings.filter(b => b.status === "pending").length,
        confirmedCount: hourBookings.filter(b => b.status === "confirmed").length,
        rejectedCount: hourBookings.filter(b => b.status === "rejected").length,
        consumedCount: hourBookings.filter(b => b.status === "consumed").length,
        cancelledCount: hourBookings.filter(b => b.status === "cancelled").length,
        expiredCount: hourBookings.filter(b => b.status === "expired").length,
        autoValidatedCount: hourBookings.filter(b => b.wasAutoValidated).length,
      };

      // Container metrics
      let totalContainers = 0;
      let pickupCount = 0;
      let dropoffCount = 0;

      for (const booking of hourBookings) {
        totalContainers += booking.containerIds.length;
        for (const containerId of booking.containerIds) {
          const container = await ctx.db.get(containerId);
          if (container?.operationType === "pick_up") pickupCount++;
          else dropoffCount++;
        }
      }

      // Capacity metrics
      const slot = await ctx.db
        .query("timeSlots")
        .withIndex("by_terminal_and_date", q =>
          q.eq("terminalId", terminal._id).eq("date", dateStr)
        )
        .filter(q => q.eq(q.field("startTime"), `${currentHour.toString().padStart(2, "0")}:00`))
        .first();

      const utilizationPercent = slot 
        ? Math.round((slot.currentBookings / slot.maxCapacity) * 100)
        : 0;

      // Timing metrics (average wait time from booking to confirm)
      const confirmedBookings = hourBookings.filter(b => b.confirmedAt);
      const avgWaitTimeMs = confirmedBookings.length > 0
        ? confirmedBookings.reduce((sum, b) => sum + (b.confirmedAt! - b.bookedAt), 0) / confirmedBookings.length
        : undefined;

      // Upsert aggregate
      const existing = await ctx.db
        .query("bookingAggregates")
        .withIndex("by_terminal_and_date", q =>
          q.eq("terminalId", terminal._id).eq("date", dateStr)
        )
        .filter(q => q.eq(q.field("hour"), currentHour))
        .first();

      if (existing) {
        await ctx.db.patch(existing._id, {
          ...metrics,
          avgUtilizationPercent: utilizationPercent,
          peakUtilizationPercent: Math.max(existing.peakUtilizationPercent, utilizationPercent),
          totalContainers,
          pickupCount,
          dropoffCount,
          avgWaitTimeMs,
          computedAt: Date.now(),
        });
      } else {
        await ctx.db.insert("bookingAggregates", {
          terminalId: terminal._id,
          period: "hourly",
          date: dateStr,
          hour: currentHour,
          ...metrics,
          avgUtilizationPercent: utilizationPercent,
          peakUtilizationPercent: utilizationPercent,
          totalContainers,
          pickupCount,
          dropoffCount,
          avgWaitTimeMs,
          computedAt: Date.now(),
        });
        count++;
      }
    }

    return count;
  },
});
```

**File: `packages/backend/convex/analytics/export.ts` (CREATE)**

```typescript
"use node";
import { action } from "../_generated/server";
import { v } from "convex/values";
import { internal } from "../_generated/api";

/**
 * Export analytics to CSV
 */
export const exportToCSV = action({
  args: {
    terminalId: v.optional(v.id("terminals")),
    startDate: v.string(),
    endDate: v.string(),
    period: v.union(v.literal("hourly"), v.literal("daily")),
  },
  returns: v.string(), // CSV content
  handler: async (ctx, args) => {
    const aggregates = await ctx.runQuery(internal.analytics.queries.getAggregates, {
      terminalId: args.terminalId,
      startDate: args.startDate,
      endDate: args.endDate,
      period: args.period,
    });

    // Build CSV
    const headers = [
      "Terminal",
      "Date",
      "Heure",
      "Total Réservations",
      "En attente",
      "Confirmées",
      "Refusées",
      "Consommées",
      "Annulées",
      "Expirées",
      "Auto-validées",
      "Utilisation %",
      "Conteneurs",
    ];

    const rows = aggregates.map(a => [
      a.terminalName,
      a.date,
      a.hour?.toString() ?? "Journée",
      a.totalBookings,
      a.pendingCount,
      a.confirmedCount,
      a.rejectedCount,
      a.consumedCount,
      a.cancelledCount,
      a.expiredCount,
      a.autoValidatedCount,
      a.avgUtilizationPercent,
      a.totalContainers,
    ]);

    const csv = [
      headers.join(","),
      ...rows.map(r => r.join(",")),
    ].join("\n");

    return csv;
  },
});
```

---

## Verification Strategy

### Unit Tests

```typescript
// packages/backend/convex/__tests__/capacity.test.ts
describe("Terminal Capacity Engine", () => {
  it("should reserve capacity atomically", async () => {
    // Test checkAndReserveCapacity
  });

  it("should release capacity on cancellation", async () => {
    // Test releaseCapacity
  });

  it("should auto-validate within threshold", async () => {
    // Test shouldAutoValidate
  });

  it("should reject auto-validation beyond threshold", async () => {
    // Test shouldAutoValidate returns false
  });
});

// packages/backend/convex/__tests__/booking.test.ts
describe("Booking Mutations", () => {
  it("should create booking with multiple containers", async () => {
    // Test create mutation
  });

  it("should assign gate at confirmation", async () => {
    // Test confirm mutation
  });

  it("should allow truck change only", async () => {
    // Test changeTruck mutation
  });
});
```

### Integration Tests

```typescript
// packages/backend/convex/__tests__/integration/booking-flow.test.ts
describe("Booking Flow Integration", () => {
  it("should complete full booking lifecycle", async () => {
    // 1. Create booking
    // 2. Confirm (with gate assignment)
    // 3. Generate QR
    // 4. Entry scan
    // 5. Exit scan
  });

  it("should handle auto-validation correctly", async () => {
    // 1. Set threshold to 50%
    // 2. Create bookings until threshold
    // 3. Verify auto-validation stops
  });
});
```

### E2E Tests (Playwright)

```typescript
// apps/web/e2e/carrier-booking.spec.ts
test("carrier can create booking via AI chat", async ({ page }) => {
  // 1. Login as carrier
  // 2. Open chat
  // 3. Say "Je veux créer une réservation"
  // 4. Follow AI prompts to select containers
  // 5. Select optimal slot
  // 6. Select truck
  // 7. Confirm booking
  // 8. Verify booking created
});

// apps/web/e2e/operator-approval.spec.ts
test("operator can approve pending bookings", async ({ page }) => {
  // 1. Login as operator
  // 2. Go to approval queue
  // 3. Select booking
  // 4. Confirm with gate selection
  // 5. Verify status change
});

// apps/web/e2e/qr-scan.spec.ts
test("operator can process QR scans", async ({ page }) => {
  // 1. Login as operator
  // 2. Go to scanner
  // 3. Scan entry QR
  // 4. Verify booking status
  // 5. Scan exit QR
  // 6. Verify completion
});
```

---

## Critical Files Summary

### Backend Core (Modify/Create)
| File | Action | Priority |
|------|--------|----------|
| `packages/backend/convex/schema.ts` | Major Refactor | P0 |
| `packages/backend/convex/lib/validators.ts` | Update | P0 |
| `packages/backend/convex/lib/permissions.ts` | Update | P0 |
| `packages/backend/convex/lib/capacity.ts` | Replace | P0 |
| `packages/backend/convex/lib/autoValidation.ts` | Create | P0 |
| `packages/backend/convex/lib/auditLog.ts` | Create | P1 |
| `packages/backend/convex/containers/queries.ts` | Create | P0 |
| `packages/backend/convex/containers/mutations.ts` | Create | P0 |
| `packages/backend/convex/bookings/mutations.ts` | Major Refactor | P0 |
| `packages/backend/convex/bookings/internal.ts` | Update | P0 |
| `packages/backend/convex/trucks/mutations.ts` | Update | P1 |
| `packages/backend/convex/ai/agent.ts` | Update | P0 |
| `packages/backend/convex/ai/registry.ts` | Update | P0 |
| `packages/backend/convex/ai/tools/containers.ts` | Create | P0 |
| `packages/backend/convex/ai/tools/slots.ts` | Create | P0 |
| `packages/backend/convex/ai/tools/booking-flow.ts` | Create | P0 |
| `packages/backend/convex/ai/tools/trucks.ts` | Create | P0 |
| `packages/backend/convex/ai/mutations.ts` | Create | P0 |
| `packages/backend/convex/qr/index.ts` | Create | P1 |
| `packages/backend/convex/qr/scan.ts` | Create | P1 |
| `packages/backend/convex/email/index.ts` | Create | P1 |
| `packages/backend/convex/analytics/compute.ts` | Create | P2 |
| `packages/backend/convex/analytics/export.ts` | Create | P2 |
| `packages/backend/convex/audit/queries.ts` | Create | P2 |
| `packages/backend/convex/seed/index.ts` | Create | P2 |
| `packages/backend/convex/crons.ts` | Update | P1 |
| `packages/backend/convex/scheduled.ts` | Update | P1 |

### Frontend (Create/Modify)
| File | Action | Priority |
|------|--------|----------|
| `apps/web/src/components/ai-elements/apcs/container-selector.tsx` | Create | P0 |
| `apps/web/src/components/ai-elements/apcs/slot-suggestions.tsx` | Create | P0 |
| `apps/web/src/components/ai-elements/apcs/booking-confirmation-card.tsx` | Create | P0 |
| `apps/web/src/features/scanner/components/qr-scanner.tsx` | Create | P1 |

---

## Timeline

| Phase | Duration | Dependencies |
|-------|----------|--------------|
| 1. Schema Refactoring | 3-4 days | None |
| 2. Core Backend Functions | 5-6 days | Phase 1 |
| 3. AI Tools | 5-7 days | Phase 1, 2 |
| 4. QR Code System | 2-3 days | Phase 2 |
| 5. Notifications + Email | 3-4 days | Phase 2 |
| 6. Cron Jobs | 1-2 days | Phase 2, 5 |
| 7. Audit Logging | 2-3 days | Phase 1 |
| 8. Seed Data | 2-3 days | All above |
| 9. Analytics | 3-4 days | Phase 8 |

**Total: 26-36 days (5-7 weeks)**
