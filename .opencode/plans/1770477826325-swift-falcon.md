# APCS AI Tool Improvements

## Phase 1 (DONE): `_display` flag system
> Already implemented. See git history for details.

---

## Phase 2: Tool Gaps — `listAllBookings` + Quick Fixes

### Problem

When a user asks *"Liste toutes les réservations en cours sur tous les terminaux"*, the AI has no single tool to answer this. It must:
1. Call `listTerminals` to discover all terminals
2. Call `listBookingsByTerminal` N times (once per terminal)

This produces N separate UI cards — confusing and noisy. The root cause is a **missing tool**, not a rendering issue.

### Solution Overview

| Priority | Change | Impact |
|----------|--------|--------|
| **Must** | New `listAllBookings` tool (backend query + tool + all registrations) | Fixes the N-cards problem |
| **Should** | Add `date` filter to `listMyBookings` internal query + tool | Enables "mes réservations de la semaine" |
| **Should** | Complete `toolDescriptions` in `chat.ts` (6 missing) | Better AI context |
| **Must** | Update system prompt to prefer `listAllBookings` over looping | Prevents AI from falling back to old pattern |

---

### Step 1: New `listAllBookings` internal query

**File:** `packages/backend/convex/ai/internalQueries.ts` (insert after `listPendingBookings` ~line 405)

```typescript
export const listAllBookings = internalQuery({
  args: {
    userId: v.string(),
    terminalCode: v.optional(v.string()),
    status: v.optional(v.string()),
    date: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const role = await getUserRoleHelper(ctx, args.userId);
    if (!role || !["port_admin", "terminal_operator"].includes(role)) {
      return [];
    }

    const limit = args.limit ?? 50;

    // Determine terminal scope (same 3-branch pattern as listPendingBookings)
    let terminalIds: Id<"terminals">[] = [];
    if (args.terminalCode) {
      const terminal = await ctx.db
        .query("terminals")
        .withIndex("by_code", (q) => q.eq("code", args.terminalCode))
        .unique();
      if (!terminal) return [];
      terminalIds = [terminal._id];
    } else if (role === "port_admin") {
      const allTerminals = await ctx.db.query("terminals").collect();
      terminalIds = allTerminals.map((t) => t._id);
    } else {
      const assignments = await ctx.db
        .query("terminalOperatorAssignments")
        .withIndex("by_user_and_active", (q) =>
          q.eq("userId", args.userId).eq("isActive", true),
        )
        .collect();
      terminalIds = assignments.map((a) => a.terminalId);
    }

    // Query bookings per terminal with optional status/date filter
    const allBookings: Doc<"bookings">[] = [];
    for (const terminalId of terminalIds) {
      let bookings: Doc<"bookings">[];

      if (args.status) {
        bookings = await ctx.db
          .query("bookings")
          .withIndex("by_terminal_and_status", (q) =>
            q.eq("terminalId", terminalId).eq("status", args.status),
          )
          .order("desc")
          .take(limit);
      } else if (args.date) {
        bookings = await ctx.db
          .query("bookings")
          .withIndex("by_terminal_and_date", (q) =>
            q.eq("terminalId", terminalId).eq("preferredDate", args.date),
          )
          .order("desc")
          .take(limit);
      } else {
        bookings = await ctx.db
          .query("bookings")
          .withIndex("by_terminal", (q) =>
            q.eq("terminalId", terminalId),
          )
          .order("desc")
          .take(limit);
      }

      allBookings.push(...bookings);
    }

    // Sort desc by creation time, slice to limit, enrich
    allBookings.sort((a, b) => b._creationTime - a._creationTime);
    return enrichBookings(ctx, allBookings.slice(0, limit));
  },
});
```

**Index strategy:** Uses existing indexes `by_terminal_and_status`, `by_terminal_and_date`, `by_terminal`. No schema changes needed.

**RBAC:** Same pattern as `listPendingBookings` — port_admin sees all terminals, terminal_operator sees assigned terminals only, carriers are denied.

---

### Step 2: New `listAllBookings` tool

**File:** `packages/backend/convex/ai/tools/bookings.ts` (append after `listPendingBookings`)

```typescript
export const listAllBookings = createTool({
  description:
    "List all bookings across all terminals. Supports optional filters by terminal, status, and date. " +
    "Use this instead of calling listBookingsByTerminal multiple times. " +
    "Only for port_admin and terminal_operator roles.",
  args: z.object({
    terminalCode: z.string().optional()
      .describe("Filter by terminal code (e.g. 'TER1'). Omit to see all terminals."),
    status: z.enum(["pending", "confirmed", "rejected", "consumed", "cancelled", "expired"]).optional()
      .describe("Filter by booking status."),
    date: z.string().optional()
      .describe("Filter by date in YYYY-MM-DD format."),
    limit: z.number().optional()
      .describe("Maximum number of results (default 50)."),
    ...displayArg,
  }),
  handler: async (ctx, args): Promise<unknown> => {
    const denied = await checkToolAccess(ctx, "listAllBookings");
    if (denied) return denied;

    const data = await ctx.runQuery(
      internal.ai.internalQueries.listAllBookings,
      {
        userId: ctx.userId!,
        terminalCode: args.terminalCode,
        status: args.status,
        date: args.date,
        limit: args.limit ?? 50,
      },
    );

    return toolResult(data, args._display ?? true);
  },
});
```

---

### Step 3: Register in backend

**File:** `packages/backend/convex/ai/tools/types.ts` — Add `"listAllBookings"` to `terminal_operator` and `port_admin` arrays in `TOOL_PERMISSIONS` (lines ~40-60).

**File:** `packages/backend/convex/ai/registry.ts` — Import `listAllBookings` from `./tools/bookings`, add to `ALL_TOOLS` object (line ~52, in the "Booking queries" section).

---

### Step 4: Register in frontend

**File:** `apps/web/src/features/tools/registry.ts`

- Add to `TOOL_RENDERERS` (line ~35): `listAllBookings: BookingListRenderer`
- Add to `TOOL_META` (after `listPendingBookings` entry): new entry with label `"Toutes les réservations"`, previewCount 3, same pattern as other booking tools

**File:** `apps/web/src/features/tools/components/tool-loading-state.tsx`

- Add to `TOOL_ICONS` (line ~20): `listAllBookings: <CalendarIcon />`
- Add to `TOOL_LABELS` (line ~38): `listAllBookings: "Chargement de toutes les réservations..."`

**File:** `apps/web/src/features/tools/components/tool-error-state.tsx`

- Add to `TOOL_ERROR_MESSAGES` (line ~18): `listAllBookings: "Impossible de charger les réservations"`

---

### Step 5: Update system prompt

**File:** `packages/backend/convex/ai/agent.ts`

Add to the system prompt (in the tool instructions section, ~line 55):

```
- Pour lister les réservations sur TOUS les terminaux, utilise 'listAllBookings' en un seul appel.
  N'appelle JAMAIS 'listBookingsByTerminal' en boucle pour chaque terminal.
  'listAllBookings' supporte les filtres: terminalCode, status, date.
```

---

### Step 6: Add date filter to `listMyBookings`

**File:** `packages/backend/convex/ai/internalQueries.ts` (~line 131)

Add `date: v.optional(v.string())` to args. When `date` is provided alongside `status`, post-filter by `preferredDate` (no compound index for `carrierId+status+date` exists, so filter in JS after the index query). When only `date` is provided without `status`, filter in JS after `by_carrier` index query.

**File:** `packages/backend/convex/ai/tools/bookings.ts` (~line 21)

Add `date` arg to the `listMyBookings` tool schema:

```typescript
date: z.string().optional()
  .describe("Filter by date in YYYY-MM-DD format."),
```

Pass `args.date` through to the internal query.

---

### Step 7: Complete `toolDescriptions` in `chat.ts`

**File:** `packages/backend/convex/ai/chat.ts` (~line 39)

Add the 7 missing entries:

```typescript
listAllBookings: "List all bookings across all terminals with optional filters (port_admin and terminal_operator only)",
listMyContainers: "List the user's containers",
getContainerDetails: "Get details of a specific container",
listMyTrucks: "List the user's trucks",
suggestOptimalSlots: "Suggest optimal time slots based on terminal congestion",
createBookingViaAI: "Create a new booking through the AI assistant",
cancelBookingViaAI: "Cancel an existing booking through the AI assistant",
```

---

## Files Modified (Phase 2)

| File | Change |
|------|--------|
| `packages/backend/convex/ai/internalQueries.ts` | New `listAllBookings` query; add `date` filter to `listMyBookings` |
| `packages/backend/convex/ai/tools/bookings.ts` | New `listAllBookings` tool; add `date` arg to `listMyBookings` |
| `packages/backend/convex/ai/tools/types.ts` | Add `listAllBookings` to `TOOL_PERMISSIONS` |
| `packages/backend/convex/ai/registry.ts` | Import + register `listAllBookings` in `ALL_TOOLS` |
| `packages/backend/convex/ai/agent.ts` | System prompt: prefer `listAllBookings` over looping |
| `packages/backend/convex/ai/chat.ts` | Complete 7 missing `toolDescriptions` |
| `apps/web/src/features/tools/registry.ts` | `TOOL_RENDERERS` + `TOOL_META` entry |
| `apps/web/src/features/tools/components/tool-loading-state.tsx` | `TOOL_ICONS` + `TOOL_LABELS` |
| `apps/web/src/features/tools/components/tool-error-state.tsx` | `TOOL_ERROR_MESSAGES` |

## Verification

1. `npx convex dev` — backend compiles without errors
2. `npx tsc --noEmit` in `apps/web` — frontend compiles without errors
3. Functional tests in AI chat:
   - **port_admin**: "Liste toutes les réservations en cours" → ONE card via `listAllBookings`
   - **port_admin**: "Réservations confirmées sur TER1" → ONE card filtered by terminal+status
   - **terminal_operator**: Same queries → sees only assigned terminals
   - **carrier**: Same queries → access denied (tool not in carrier permissions)
   - **carrier**: "Mes réservations du 2026-02-10" → filtered by date (new date filter on `listMyBookings`)
   - **Existing tools still work**: "Détails de la réservation TER1-BK-001234" → `getBookingDetails` still renders correctly
4. Verify `BookingListRenderer` correctly renders the enriched data shape (field normalization from Phase 1 already handles `date`→`preferredDate` etc.)
