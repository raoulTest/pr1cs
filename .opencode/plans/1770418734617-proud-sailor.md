# Plan de Correction APCS - Conformité Backend

## Résumé des Non-Conformités Identifiées

### Problèmes Critiques (HAUTE priorité)

| # | Problème | Fichier(s) | Impact |
|---|----------|-----------|--------|
| 1 | **Capacité granulaire par slot impossible** | `lib/capacity.ts:64-83` | Les slots virtuels héritent toujours de `terminal.defaultSlotCapacity` |
| 2 | **Audit logging non implémenté** | Toutes les mutations | La table `auditLogs` existe mais jamais utilisée |
| 3 | **Outils AI manquants pour containers** | `ai/tools/` | Pas d'outils pour lister/sélectionner les containers |
| 4 | **Outil suggestion slots manquant** | `ai/tools/` | Pas d'optimisation load balancing + urgency |
| 5 | **Outils AI mutation manquants** | `ai/tools/` | Pas d'outil pour créer booking via AI |
| 6 | **Agent non français-only** | `ai/agent.ts:45` | Répond en FR/EN au lieu de FR uniquement |

### Problèmes Moyens (MOYENNE priorité)

| # | Problème | Fichier(s) | Impact |
|---|----------|-----------|--------|
| 7 | **Bulk update templates manquant** | N/A | Pas de mutation pour modifier plusieurs templates |
| 8 | **Terminaux pas 24/7 par défaut** | `terminals/mutations.ts:57-58` | Default 06:00-22:00 au lieu de 00:00-23:59 |

---

## Phase 1: Capacité Granulaire par Slot (slotTemplates)

### Logique Métier Clarifiée

**Lors de la création d'un terminal:**
1. Créer **168 `slotTemplates`** (7 jours × 24 heures)
2. Chaque template a `maxCapacity` = `terminal.defaultSlotCapacity`
3. Templates **hors heures d'opération** → `isActive: false`
4. Templates **dans heures d'opération** → `isActive: true`

**Après création:**
- ✅ Modifier la capacité d'un ou plusieurs templates (bulk update)
- ✅ Activer/désactiver un ou plusieurs templates (bulk toggle)
- ❌ Les defaults du terminal (`defaultSlotCapacity`, `operatingHoursStart/End`) sont immuables

### 1.1 Ajouter table `slotTemplates` au schéma

**Fichier:** `packages/backend/convex/schema.ts`

```typescript
// Ajouter après timeSlots
slotTemplates: defineTable({
  terminalId: v.id("terminals"),
  dayOfWeek: v.number(), // 0=Dimanche, 1=Lundi, ..., 6=Samedi
  hour: v.number(), // 0-23
  maxCapacity: v.number(),
  isActive: v.boolean(),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_terminal", ["terminalId"])
  .index("by_terminal_and_day", ["terminalId", "dayOfWeek"])
  .index("by_terminal_day_hour", ["terminalId", "dayOfWeek", "hour"]),
```

### 1.2 Modifier la mutation `terminals/create` pour créer les 168 templates

**Fichier:** `packages/backend/convex/terminals/mutations.ts`

Après l'insertion du terminal, ajouter :

```typescript
// Après: return await ctx.db.insert("terminals", {...});
// Remplacer par:

const terminalId = await ctx.db.insert("terminals", {
  name: args.name,
  code: args.code,
  address: args.address,
  timezone: args.timezone,
  isActive: true,
  defaultSlotCapacity: args.defaultSlotCapacity ?? 20,
  autoValidationThreshold: args.autoValidationThreshold ?? 50,
  capacityAlertThresholds: args.capacityAlertThresholds ?? [70, 85, 95],
  operatingHoursStart: args.operatingHoursStart ?? "00:00",
  operatingHoursEnd: args.operatingHoursEnd ?? "23:59",
  slotDurationMinutes: args.slotDurationMinutes ?? 60,
  createdAt: now,
  updatedAt: now,
  createdBy: user.userId,
});

// Créer les 168 slot templates (7 jours × 24 heures)
const defaultCapacity = args.defaultSlotCapacity ?? 20;
const opStart = args.operatingHoursStart ?? "00:00";
const opEnd = args.operatingHoursEnd ?? "23:59";
const opStartHour = parseInt(opStart.split(":")[0], 10);
const opEndHour = parseInt(opEnd.split(":")[0], 10);

for (let dayOfWeek = 0; dayOfWeek < 7; dayOfWeek++) {
  for (let hour = 0; hour < 24; hour++) {
    // Déterminer si ce créneau est dans les heures d'opération
    const isActive = hour >= opStartHour && hour <= opEndHour;
    
    await ctx.db.insert("slotTemplates", {
      terminalId,
      dayOfWeek,
      hour,
      maxCapacity: defaultCapacity,
      isActive,
      createdAt: now,
      updatedAt: now,
    });
  }
}

return terminalId;
```

### 1.3 Supprimer les champs modifiables de `terminals/update`

**Fichier:** `packages/backend/convex/terminals/mutations.ts`

Retirer de la mutation `update` :
- `defaultSlotCapacity`
- `autoValidationThreshold` 
- `operatingHoursStart`
- `operatingHoursEnd`
- `slotDurationMinutes`

Ces valeurs sont maintenant **immuables** après création.

### 1.4 Modifier `checkAndReserveCapacity` pour utiliser templates

**Fichier:** `packages/backend/convex/lib/capacity.ts`

Modifier la création de slot virtuel:

```typescript
if (!slot) {
  const terminal = await ctx.db.get(terminalId);
  if (!terminal) {
    return { success: false, error: "Terminal introuvable" };
  }

  // Chercher template pour ce jour/heure
  const dateObj = new Date(date);
  const dayOfWeek = dateObj.getDay();
  const hour = parseInt(startTime.split(":")[0], 10);
  
  const template = await ctx.db
    .query("slotTemplates")
    .withIndex("by_terminal_day_hour", (q) =>
      q.eq("terminalId", terminalId).eq("dayOfWeek", dayOfWeek).eq("hour", hour)
    )
    .first();

  if (!template) {
    return { success: false, error: "Template de créneau introuvable" };
  }

  if (!template.isActive) {
    return { success: false, error: "Ce créneau horaire n'est pas disponible" };
  }

  const now = Date.now();
  const slotId = await ctx.db.insert("timeSlots", {
    terminalId,
    date,
    startTime,
    endTime,
    maxCapacity: template.maxCapacity,
    autoValidationThreshold: terminal.autoValidationThreshold,
    currentBookings: 0,
    isActive: true,
    createdAt: now,
    updatedAt: now,
    createdBy: "system",
  });

  slot = await ctx.db.get(slotId);
}
```

### 1.5 Modifier `getTerminalCapacityForDate` pour utiliser templates

**Fichier:** `packages/backend/convex/lib/capacity.ts`

Pour les slots virtuels:

```typescript
} else {
  // Virtual slot - get from template
  const dateObj = new Date(date);
  const dayOfWeek = dateObj.getDay();
  const hour = parseInt(startTime.split(":")[0], 10);
  
  const template = await ctx.db
    .query("slotTemplates")
    .withIndex("by_terminal_day_hour", (q) =>
      q.eq("terminalId", terminalId).eq("dayOfWeek", dayOfWeek).eq("hour", hour)
    )
    .first();

  // Si pas de template, skip ce slot
  if (!template) continue;

  const capacity = template.maxCapacity;
  const threshold = terminal.autoValidationThreshold;
  const maxAutoValidated = Math.floor((capacity * threshold) / 100);

  results.push({
    slotId: undefined,
    date,
    startTime,
    endTime,
    available: capacity,
    total: capacity,
    booked: 0,
    utilizationPercent: 0,
    autoValidationThreshold: threshold,
    autoValidatedCount: 0,
    remainingAutoValidation: maxAutoValidated,
    isVirtual: true,
    isActive: template.isActive,
  });
}
```

---

## Phase 2: Mutations slotTemplates

### 2.1 Créer `slotTemplates/mutations.ts`

**Fichier:** `packages/backend/convex/slotTemplates/mutations.ts` (nouveau)

```typescript
import { mutation } from "../_generated/server";
import { v } from "convex/values";
import { ConvexError } from "convex/values";
import { getAuthenticatedUser, requireRole, requireTerminalAccess } from "../lib/permissions";

/**
 * Update a single slot template
 */
export const update = mutation({
  args: {
    templateId: v.id("slotTemplates"),
    maxCapacity: v.optional(v.number()),
    isActive: v.optional(v.boolean()),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);
    requireRole(user, ["port_admin", "terminal_operator"]);

    const template = await ctx.db.get(args.templateId);
    if (!template) {
      throw new ConvexError({
        code: "NOT_FOUND",
        message: "Template introuvable",
      });
    }

    await requireTerminalAccess(ctx, user, template.terminalId);

    const updates: Record<string, unknown> = { updatedAt: Date.now() };
    if (args.maxCapacity !== undefined) updates.maxCapacity = args.maxCapacity;
    if (args.isActive !== undefined) updates.isActive = args.isActive;

    await ctx.db.patch(args.templateId, updates);
    return null;
  },
});

/**
 * Bulk update multiple slot templates
 */
export const bulkUpdate = mutation({
  args: {
    templateIds: v.array(v.id("slotTemplates")),
    maxCapacity: v.optional(v.number()),
    isActive: v.optional(v.boolean()),
  },
  returns: v.object({ updated: v.number(), failed: v.number() }),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);
    requireRole(user, ["port_admin", "terminal_operator"]);

    let updated = 0;
    let failed = 0;
    const now = Date.now();

    for (const templateId of args.templateIds) {
      const template = await ctx.db.get(templateId);
      if (!template) {
        failed++;
        continue;
      }

      try {
        await requireTerminalAccess(ctx, user, template.terminalId);
      } catch {
        failed++;
        continue;
      }

      const updates: Record<string, unknown> = { updatedAt: now };
      if (args.maxCapacity !== undefined) updates.maxCapacity = args.maxCapacity;
      if (args.isActive !== undefined) updates.isActive = args.isActive;

      await ctx.db.patch(templateId, updates);
      updated++;
    }

    return { updated, failed };
  },
});
```

### 2.2 Créer `slotTemplates/queries.ts`

**Fichier:** `packages/backend/convex/slotTemplates/queries.ts` (nouveau)

```typescript
import { query } from "../_generated/server";
import { v } from "convex/values";
import { getAuthenticatedUser, requireTerminalAccess } from "../lib/permissions";

/**
 * Get all templates for a terminal (168 rows)
 */
export const listByTerminal = query({
  args: { terminalId: v.id("terminals") },
  returns: v.array(v.object({
    _id: v.id("slotTemplates"),
    dayOfWeek: v.number(),
    hour: v.number(),
    maxCapacity: v.number(),
    isActive: v.boolean(),
  })),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);
    await requireTerminalAccess(ctx, user, args.terminalId);

    const templates = await ctx.db
      .query("slotTemplates")
      .withIndex("by_terminal", (q) => q.eq("terminalId", args.terminalId))
      .collect();

    return templates.map((t) => ({
      _id: t._id,
      dayOfWeek: t.dayOfWeek,
      hour: t.hour,
      maxCapacity: t.maxCapacity,
      isActive: t.isActive,
    }));
  },
});

/**
 * Get templates for a specific day
 */
export const listByDay = query({
  args: { 
    terminalId: v.id("terminals"),
    dayOfWeek: v.number(),
  },
  returns: v.array(v.object({
    _id: v.id("slotTemplates"),
    hour: v.number(),
    maxCapacity: v.number(),
    isActive: v.boolean(),
  })),
  handler: async (ctx, args) => {
    const user = await getAuthenticatedUser(ctx);
    await requireTerminalAccess(ctx, user, args.terminalId);

    const templates = await ctx.db
      .query("slotTemplates")
      .withIndex("by_terminal_and_day", (q) => 
        q.eq("terminalId", args.terminalId).eq("dayOfWeek", args.dayOfWeek)
      )
      .collect();

    return templates
      .map((t) => ({
        _id: t._id,
        hour: t.hour,
        maxCapacity: t.maxCapacity,
        isActive: t.isActive,
      }))
      .sort((a, b) => a.hour - b.hour);
  },
});
```

---

## Phase 3: Audit Logging

### 3.1 Créer `audit/mutations.ts`

**Fichier:** `packages/backend/convex/audit/mutations.ts` (nouveau)

```typescript
import { internalMutation } from "../_generated/server";
import { v } from "convex/values";
import { auditActionValidator } from "../schema";

/**
 * Log an action to audit trail (internal only)
 */
export const log = internalMutation({
  args: {
    userId: v.optional(v.string()),
    action: auditActionValidator,
    resource: v.string(),
    resourceId: v.optional(v.string()),
    args: v.optional(v.string()),
    result: v.optional(v.string()),
    errorMessage: v.optional(v.string()),
    ipAddress: v.optional(v.string()),
    userAgent: v.optional(v.string()),
    sessionId: v.optional(v.string()),
    aiThreadId: v.optional(v.string()),
    aiToolName: v.optional(v.string()),
    durationMs: v.optional(v.number()),
  },
  returns: v.id("auditLogs"),
  handler: async (ctx, args) => {
    return await ctx.db.insert("auditLogs", {
      ...args,
      timestamp: Date.now(),
    });
  },
});
```

### 3.2 Créer helper pour audit logging

**Fichier:** `packages/backend/convex/lib/audit.ts` (nouveau)

```typescript
import type { MutationCtx } from "../_generated/server";
import { internal } from "../_generated/api";
import type { AuditAction } from "../schema";

export interface AuditLogParams {
  userId?: string;
  action: AuditAction;
  resource: string;
  resourceId?: string;
  args?: Record<string, unknown>;
  result?: string;
  errorMessage?: string;
  aiThreadId?: string;
  aiToolName?: string;
}

/**
 * Log action to audit trail
 */
export async function logAudit(
  ctx: MutationCtx,
  params: AuditLogParams
): Promise<void> {
  // Sanitize args (remove sensitive data)
  const sanitizedArgs = params.args
    ? JSON.stringify(sanitizeArgs(params.args))
    : undefined;

  await ctx.runMutation(internal.audit.mutations.log, {
    userId: params.userId,
    action: params.action,
    resource: params.resource,
    resourceId: params.resourceId,
    args: sanitizedArgs,
    result: params.result,
    errorMessage: params.errorMessage,
    aiThreadId: params.aiThreadId,
    aiToolName: params.aiToolName,
  });
}

/**
 * Remove sensitive fields from args before logging
 */
function sanitizeArgs(args: Record<string, unknown>): Record<string, unknown> {
  const sensitiveFields = [
    "password",
    "token",
    "secret",
    "apiKey",
    "driverIdNumber",
  ];
  
  const sanitized: Record<string, unknown> = {};
  
  for (const [key, value] of Object.entries(args)) {
    if (sensitiveFields.some(f => key.toLowerCase().includes(f.toLowerCase()))) {
      sanitized[key] = "[REDACTED]";
    } else if (typeof value === "object" && value !== null) {
      sanitized[key] = sanitizeArgs(value as Record<string, unknown>);
    } else {
      sanitized[key] = value;
    }
  }
  
  return sanitized;
}
```

### 3.3 Ajouter audit logging aux mutations critiques

**Exemple pour `bookings/mutations.ts`:**

```typescript
import { logAudit } from "../lib/audit";

// Dans la mutation create, après l'insert:
await logAudit(ctx, {
  userId: user.userId,
  action: "mutation",
  resource: "bookings.create",
  resourceId: bookingId,
  args: { terminalId: args.terminalId, truckId: args.truckId, containerIds: args.containerIds },
  result: wasAutoValidated ? "auto_validated" : "pending",
});
```

---

## Phase 4: Outils AI Manquants

### 4.1 Créer `ai/tools/containers.ts`

**Fichier:** `packages/backend/convex/ai/tools/containers.ts` (nouveau)

```typescript
import { createTool } from "@convex-dev/agent";
import { z } from "zod";
import { internal } from "../../_generated/api";
import { checkToolAccess } from "./types";

export const listMyContainers = createTool({
  description:
    "Liste les conteneurs du transporteur. Peut filtrer par type d'opération (enlèvement/dépôt) ou disponibilité.",
  args: z.object({
    operationType: z
      .enum(["pick_up", "drop_off"])
      .optional()
      .describe("Filtrer par type d'opération"),
    available: z
      .boolean()
      .optional()
      .describe("Uniquement les conteneurs non assignés à une réservation"),
    limit: z.number().optional().describe("Nombre maximum (défaut 50)"),
  }),
  handler: async (ctx, args) => {
    const denied = await checkToolAccess(ctx, "listMyContainers");
    if (denied) return denied;

    return await ctx.runQuery(internal.ai.internalQueries.listMyContainers, {
      userId: ctx.userId!,
      operationType: args.operationType,
      available: args.available ?? true,
      limit: args.limit ?? 50,
    });
  },
});

export const getContainerDetails = createTool({
  description: "Obtient les détails d'un conteneur spécifique.",
  args: z.object({
    containerId: z.string().describe("ID du conteneur"),
  }),
  handler: async (ctx, args) => {
    const denied = await checkToolAccess(ctx, "getContainerDetails");
    if (denied) return denied;

    return await ctx.runQuery(internal.ai.internalQueries.getContainerDetails, {
      userId: ctx.userId!,
      containerId: args.containerId,
    });
  },
});
```

### 4.2 Créer `ai/tools/suggestions.ts`

**Fichier:** `packages/backend/convex/ai/tools/suggestions.ts` (nouveau)

```typescript
import { createTool } from "@convex-dev/agent";
import { z } from "zod";
import { internal } from "../../_generated/api";
import { checkToolAccess } from "./types";

export const suggestOptimalSlots = createTool({
  description:
    "Suggère les 5 meilleurs créneaux horaires pour une réservation. " +
    "Prend en compte: équilibrage de charge, urgence des conteneurs, temps d'attente minimal.",
  args: z.object({
    terminalId: z.string().describe("ID du terminal"),
    containerIds: z.array(z.string()).describe("IDs des conteneurs à transporter"),
    preferredDate: z.string().optional().describe("Date préférée (YYYY-MM-DD)"),
  }),
  handler: async (ctx, args) => {
    const denied = await checkToolAccess(ctx, "suggestOptimalSlots");
    if (denied) return denied;

    return await ctx.runQuery(internal.ai.internalQueries.suggestOptimalSlots, {
      userId: ctx.userId!,
      terminalId: args.terminalId,
      containerIds: args.containerIds,
      preferredDate: args.preferredDate,
    });
  },
});
```

### 4.3 Créer `ai/tools/bookingFlow.ts`

**Fichier:** `packages/backend/convex/ai/tools/bookingFlow.ts` (nouveau)

```typescript
import { createTool } from "@convex-dev/agent";
import { z } from "zod";
import { internal } from "../../_generated/api";
import { checkToolAccess } from "./types";

export const createBookingViaAI = createTool({
  description:
    "Crée une réservation. Retourne une carte de confirmation avec le statut (auto-validé ou en attente).",
  args: z.object({
    terminalId: z.string().describe("ID du terminal"),
    truckId: z.string().describe("ID du camion"),
    containerIds: z.array(z.string()).describe("IDs des conteneurs"),
    slotDate: z.string().describe("Date (YYYY-MM-DD)"),
    slotStartTime: z.string().describe("Heure de début (HH:mm)"),
    slotEndTime: z.string().describe("Heure de fin (HH:mm)"),
    driverName: z.string().optional(),
    driverPhone: z.string().optional(),
  }),
  handler: async (ctx, args) => {
    const denied = await checkToolAccess(ctx, "createBookingViaAI");
    if (denied) return denied;

    return await ctx.runMutation(internal.ai.mutations.createBookingFromAI, {
      userId: ctx.userId!,
      ...args,
    });
  },
});

export const cancelBookingViaAI = createTool({
  description: "Annule une réservation existante.",
  args: z.object({
    bookingReference: z.string().describe("Référence de la réservation (ex: TER1-BK-001234)"),
    reason: z.string().optional().describe("Raison de l'annulation"),
  }),
  handler: async (ctx, args) => {
    const denied = await checkToolAccess(ctx, "cancelBookingViaAI");
    if (denied) return denied;

    return await ctx.runMutation(internal.ai.mutations.cancelBookingFromAI, {
      userId: ctx.userId!,
      bookingReference: args.bookingReference,
      reason: args.reason,
    });
  },
});
```

### 4.4 Mettre à jour `ai/registry.ts`

```typescript
// Ajouter les imports
import { listMyContainers, getContainerDetails } from "./tools/containers";
import { suggestOptimalSlots } from "./tools/suggestions";
import { createBookingViaAI, cancelBookingViaAI } from "./tools/bookingFlow";

// Mettre à jour ALL_TOOLS
export const ALL_TOOLS = {
  // Existing
  listMyBookings,
  getBookingDetails,
  listBookingsByTerminal,
  listBookingsByCarrier,
  listPendingBookings,
  listTerminals,
  getTerminalDetails,
  getAvailableSlots,
  getSystemConfig,
  // New - Containers
  listMyContainers,
  getContainerDetails,
  // New - Suggestions
  suggestOptimalSlots,
  // New - Booking Flow
  createBookingViaAI,
  cancelBookingViaAI,
};
```

### 4.5 Mettre à jour `ai/tools/types.ts`

```typescript
export const TOOL_PERMISSIONS: Record<ApcsRole, readonly string[]> = {
  carrier: [
    "listMyBookings",
    "getBookingDetails",
    "listTerminals",
    "getTerminalDetails",
    "getAvailableSlots",
    "getSystemConfig",
    // New
    "listMyContainers",
    "getContainerDetails",
    "suggestOptimalSlots",
    "createBookingViaAI",
    "cancelBookingViaAI",
  ],
  terminal_operator: [
    "listMyBookings",
    "getBookingDetails",
    "listTerminals",
    "getTerminalDetails",
    "getAvailableSlots",
    "listBookingsByTerminal",
    "listPendingBookings",
    "getSystemConfig",
    // New
    "listMyContainers",
    "getContainerDetails",
    "suggestOptimalSlots",
  ],
  port_admin: [
    "listMyBookings",
    "getBookingDetails",
    "listTerminals",
    "getTerminalDetails",
    "getAvailableSlots",
    "listBookingsByTerminal",
    "listBookingsByCarrier",
    "listPendingBookings",
    "getSystemConfig",
    // New
    "listMyContainers",
    "getContainerDetails",
    "suggestOptimalSlots",
  ],
};
```

### 4.6 Mettre à jour `ai/agent.ts` pour français-only

**Fichier:** `packages/backend/convex/ai/agent.ts`

Modifier ligne 45:

```typescript
// AVANT:
// - Respond in the same language the user writes in (French or English).

// APRÈS:
// - Réponds TOUJOURS en français, quelle que soit la langue utilisée par l'utilisateur.
```

---

## Phase 5: Corrections Mineures

### 5.1 Terminaux 24/7 par défaut

**Fichier:** `packages/backend/convex/terminals/mutations.ts`

Modifier lignes 57-58:

```typescript
// AVANT:
operatingHoursStart: args.operatingHoursStart ?? "06:00",
operatingHoursEnd: args.operatingHoursEnd ?? "22:00",

// APRÈS:
operatingHoursStart: args.operatingHoursStart ?? "00:00",
operatingHoursEnd: args.operatingHoursEnd ?? "23:59",
```

---

## Fichiers à Créer

| Fichier | Description |
|---------|-------------|
| `packages/backend/convex/slotTemplates/mutations.ts` | `update` + `bulkUpdate` templates |
| `packages/backend/convex/slotTemplates/queries.ts` | `listByTerminal` + `listByDay` |
| `packages/backend/convex/audit/mutations.ts` | Logging audit interne |
| `packages/backend/convex/lib/audit.ts` | Helper `logAudit` |
| `packages/backend/convex/ai/tools/containers.ts` | Outils containers |
| `packages/backend/convex/ai/tools/suggestions.ts` | Outil suggestions slots |
| `packages/backend/convex/ai/tools/bookingFlow.ts` | Outils création booking |
| `packages/backend/convex/ai/internalQueries.ts` | Queries internes pour AI |
| `packages/backend/convex/ai/mutations.ts` | Mutations internes pour AI |

## Fichiers à Modifier

| Fichier | Modifications |
|---------|---------------|
| `packages/backend/convex/schema.ts` | Ajouter table `slotTemplates` |
| `packages/backend/convex/terminals/mutations.ts` | Créer 168 templates + default 24/7 + retirer champs immuables de `update` |
| `packages/backend/convex/lib/capacity.ts` | Utiliser templates pour slots virtuels |
| `packages/backend/convex/ai/registry.ts` | Ajouter nouveaux outils |
| `packages/backend/convex/ai/tools/types.ts` | Mettre à jour permissions |
| `packages/backend/convex/ai/agent.ts` | Français-only |
| `packages/backend/convex/bookings/mutations.ts` | Ajouter audit logging |
| `packages/backend/convex/trucks/mutations.ts` | Ajouter audit logging |
| `packages/backend/convex/containers/mutations.ts` | Ajouter audit logging |

---

## Vérification

Pour vérifier les corrections:

1. `bun run check-types` - Vérifier les types TypeScript
2. `bun run dev:server` - Démarrer le serveur Convex
3. Tester les nouvelles mutations via le dashboard Convex
4. Tester les outils AI via l'interface de chat
